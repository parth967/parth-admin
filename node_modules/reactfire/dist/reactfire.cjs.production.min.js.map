{"version":3,"file":"reactfire.cjs.production.min.js","sources":["../src/sdk.tsx","../src/firebaseApp.tsx","../src/auth.tsx","../src/database.tsx","../src/SuspenseSubject.ts","../src/useObservable.ts","../src/firestore.tsx","../src/remote-config/getValue.tsx","../src/remote-config/index.tsx","../src/storage.tsx","../src/index.ts","../src/performance.tsx"],"sourcesContent":["import { useFirebaseApp, useSuspenseEnabledFromConfigAndContext, preloadObservable } from './';\nimport firebase from 'firebase/app';\nimport { Observable } from 'rxjs';\n\ntype ComponentName = 'analytics' | 'auth' | 'database' | 'firestore' | 'functions' | 'messaging' | 'performance' | 'remoteConfig' | 'storage';\n\ntype ValueOf<T> = T[keyof T];\ntype App = firebase.app.App;\ntype FirebaseInstanceFactory = ValueOf<Pick<App, ComponentName>>;\ntype FirebaseNamespaceComponent = ValueOf<Pick<typeof firebase, ComponentName>>;\n\nfunction importSDK(sdk: ComponentName) {\n  switch (sdk) {\n    case 'analytics':\n      return import(/* webpackChunkName: \"analytics\" */ 'firebase/analytics');\n    case 'auth':\n      return import(/* webpackChunkName: \"auth\" */ 'firebase/auth');\n    case 'database':\n      return import(/* webpackChunkName: \"database\" */ 'firebase/database');\n    case 'firestore':\n      return import(/* webpackChunkName: \"firestore\" */ 'firebase/firestore');\n    case 'functions':\n      return import(/* webpackChunkName: \"functions\" */ 'firebase/functions');\n    case 'messaging':\n      return import(/* webpackChunkName: \"messaging\" */ 'firebase/messaging');\n    case 'performance':\n      return import(/* webpackChunkName: \"performance\" */ 'firebase/performance');\n    case 'remoteConfig':\n      return import(/* webpackChunkName: \"remoteConfig\" */ 'firebase/remote-config');\n    case 'storage':\n      return import(/* webpackChunkName: \"storage\" */ 'firebase/storage');\n  }\n}\n\nfunction proxyComponent(componentName: 'auth'): typeof firebase.auth;\nfunction proxyComponent(componentName: 'analytics'): typeof firebase.analytics;\nfunction proxyComponent(componentName: 'database'): typeof firebase.database;\nfunction proxyComponent(componentName: 'firestore'): typeof firebase.firestore;\nfunction proxyComponent(componentName: 'functions'): typeof firebase.functions;\nfunction proxyComponent(componentName: 'messaging'): typeof firebase.messaging;\nfunction proxyComponent(componentName: 'performance'): typeof firebase.performance;\nfunction proxyComponent(componentName: 'remoteConfig'): typeof firebase.remoteConfig;\nfunction proxyComponent(componentName: 'storage'): typeof firebase.storage;\nfunction proxyComponent(componentName: ComponentName): FirebaseNamespaceComponent {\n  let contextualApp: App | undefined;\n  const useComponent = (app?: App, suspense?: boolean) => {\n    contextualApp = useFirebaseApp();\n    const suspenseEnabled = useSuspenseEnabledFromConfigAndContext(suspense);\n\n    const sdkSubject = preload(componentName, app || contextualApp);\n\n    if (!sdkSubject.hasValue && suspenseEnabled) {\n      throw sdkSubject.firstEmission;\n    } else if (!sdkSubject.hasValue && !suspenseEnabled && !firebase[componentName]) {\n      throw new Error(\n        `ReactFire: \"firebase/${componentName}\" not found. Please import it in your component, or call preload${componentName.charAt(0).toUpperCase() +\n          componentName.slice(1)} and wait for it to resolve. ReactFire can only auto-import Firebase libraries if Suspense mode is enabled.`\n      );\n    }\n\n    // get value to throw if there's an error\n    sdkSubject.value; // eslint-disable-line @typescript-eslint/no-unused-expressions\n    return firebase[componentName];\n  };\n  return new Proxy(useComponent, {\n    // @ts-ignore: TODO: Fix the types here\n    get: (target, p) => target()[p],\n    apply: (target, _this, args) => {\n      const component = target(args[0]).bind(_this);\n      // If they don't pass an app, assume the app in context rather than [DEFAULT]\n      if (!args[0]) {\n        args[0] = contextualApp;\n      }\n      return component(...args);\n    }\n  }) as any;\n}\n\nexport const useAuth = proxyComponent('auth');\nexport const useAnalytics = proxyComponent('analytics');\nexport const useDatabase = proxyComponent('database');\nexport const useFirestore = proxyComponent('firestore');\nexport const useFunctions = proxyComponent('functions');\nexport const useMessaging = proxyComponent('messaging');\nexport const usePerformance = proxyComponent('performance');\nexport const useRemoteConfig = proxyComponent('remoteConfig');\nexport const useStorage = proxyComponent('storage');\n\nexport const auth = useAuth;\nexport const analytics = useAnalytics;\nexport const database = useDatabase;\nexport const firestore = useFirestore;\nexport const functions = useFunctions;\nexport const messaging = useMessaging;\nexport const performance = usePerformance;\nexport const remoteConfig = useRemoteConfig;\nexport const storage = useStorage;\n\nexport type PreloadOptions<T> = {\n  firebaseApp: App;\n  setup?: (instanceFactory: T) => void | Promise<any>;\n  suspense?: boolean;\n};\n\nfunction preloadFactory(componentName: 'auth'): (options: PreloadOptions<App['auth']>) => Promise<App['auth']>;\nfunction preloadFactory(componentName: 'analytics'): (options: PreloadOptions<App['analytics']>) => Promise<App['analytics']>;\nfunction preloadFactory(componentName: 'database'): (options: PreloadOptions<App['database']>) => Promise<App['database']>;\nfunction preloadFactory(componentName: 'firestore'): (options: PreloadOptions<App['firestore']>) => Promise<App['firestore']>;\nfunction preloadFactory(componentName: 'functions'): (options: PreloadOptions<App['functions']>) => Promise<App['functions']>;\nfunction preloadFactory(componentName: 'messaging'): (options: PreloadOptions<App['messaging']>) => Promise<App['messaging']>;\nfunction preloadFactory(componentName: 'performance'): (options: PreloadOptions<App['performance']>) => Promise<App['performance']>;\nfunction preloadFactory(componentName: 'remoteConfig'): (options: PreloadOptions<App['remoteConfig']>) => Promise<App['remoteConfig']>;\nfunction preloadFactory(componentName: 'storage'): (options: PreloadOptions<App['storage']>) => Promise<App['storage']>;\nfunction preloadFactory(componentName: ComponentName) {\n  return (options: PreloadOptions<FirebaseInstanceFactory>) => preload(componentName, options.firebaseApp, options.setup).toPromise();\n}\n\nfunction preload(componentName: ComponentName, firebaseApp: App, settingsCallback: (instanceFactory: FirebaseInstanceFactory) => any = () => {}) {\n  const app = firebaseApp;\n\n  return preloadObservable(\n    new Observable(emitter => {\n      importSDK(componentName)\n        .then(() => {\n          const instanceFactory: FirebaseInstanceFactory = app[componentName].bind(app);\n          Promise.resolve(settingsCallback(instanceFactory)).then(() => {\n            emitter.next(instanceFactory);\n            emitter.complete();\n          });\n        })\n        .catch(e => {\n          emitter.error(e);\n          emitter.complete();\n        });\n    }),\n    `firebase-sdk:${componentName}:${app.name}`\n  );\n}\n\nexport const preloadAuth = preloadFactory('auth');\nexport const preloadAnalytics = preloadFactory('analytics');\nexport const preloadDatabase = preloadFactory('database');\nexport const preloadFirestore = preloadFactory('firestore');\nexport const preloadFunctions = preloadFactory('functions');\nexport const preloadMessaging = preloadFactory('messaging');\nexport const preloadPerformance = preloadFactory('performance');\nexport const preloadRemoteConfig = preloadFactory('remoteConfig');\nexport const preloadStorage = preloadFactory('storage');\n","import firebase from 'firebase/app';\nimport * as React from 'react';\n\nexport * from './sdk';\n\ntype FirebaseAppContextValue = firebase.app.App;\n\n// INVESTIGATE I don't like magic strings, can we have export this in js-sdk?\nconst DEFAULT_APP_NAME = '[DEFAULT]';\n\nconst FirebaseAppContext = React.createContext<FirebaseAppContextValue | undefined>(undefined);\n\nconst SuspenseEnabledContext = React.createContext<boolean>(false);\n\ntype Props = {\n  firebaseApp?: firebase.app.App;\n  firebaseConfig?: Object;\n  appName?: string;\n  suspense?: boolean;\n};\n\n// @ts-ignore: \"__REACTFIRE_VERSION__\" is replaced with actual ReactFire version (see babel.config.js)\nexport const version = __REACTFIRE_VERSION__;\n\nconst shallowEq = (a: { [key: string]: any }, b: { [key: string]: any }) => a === b || [...Object.keys(a), ...Object.keys(b)].every(key => a[key] === b[key]);\n\nexport function FirebaseAppProvider(props: Props & { [key: string]: unknown }) {\n  const { firebaseConfig, appName, suspense } = props;\n\n  const firebaseApp: firebase.app.App = React.useMemo(() => {\n    if (props.firebaseApp) {\n      return props.firebaseApp;\n    }\n\n    const existingApp = firebase.apps.find(app => app.name === (appName || DEFAULT_APP_NAME));\n    if (existingApp) {\n      if (firebaseConfig && shallowEq(existingApp.options, firebaseConfig)) {\n        return existingApp;\n      } else {\n        throw new Error(\n          `Does not match the options already provided to the ${appName || 'default'} firebase app instance, give this new instance a different appName.`\n        );\n      }\n    } else {\n      if (!firebaseConfig) {\n        throw new Error('No firebaseConfig provided');\n      }\n\n      // TODO: DOUBLE CHECK THAT THIS GETS CALLED\n      const reactVersion = React.version || 'unknown';\n      firebase.registerVersion('react', reactVersion);\n      firebase.registerVersion('reactfire', version);\n      return firebase.initializeApp(firebaseConfig, appName);\n    }\n  }, [props.firebaseApp, firebaseConfig, appName]);\n\n  return (\n    <FirebaseAppContext.Provider value={firebaseApp}>\n      <SuspenseEnabledContext.Provider value={suspense ?? false} {...props} />\n    </FirebaseAppContext.Provider>\n  );\n}\n\nexport function useIsSuspenseEnabled(): boolean {\n  const suspense = React.useContext(SuspenseEnabledContext);\n\n  // default to false if not available in context\n  return suspense ?? false;\n}\n\nexport function useSuspenseEnabledFromConfigAndContext(suspenseFromConfig?: boolean): boolean {\n  let suspenseFromContext = React.useContext(SuspenseEnabledContext);\n\n  // prioritize config over context\n  if (suspenseFromConfig !== undefined) {\n    return suspenseFromConfig;\n  }\n\n  return suspenseFromContext;\n}\n\nexport function useFirebaseApp() {\n  const firebaseApp = React.useContext(FirebaseAppContext);\n  if (!firebaseApp) {\n    throw new Error('Cannot call useFirebaseApp unless your component is within a FirebaseAppProvider');\n  }\n\n  return firebaseApp;\n}\n","import firebase from 'firebase/app';\nimport * as React from 'react';\nimport { user } from 'rxfire/auth';\nimport { preloadAuth, preloadObservable, ReactFireOptions, useAuth, useObservable, ObservableStatus } from './';\nimport { from } from 'rxjs';\nimport { useFirebaseApp } from './firebaseApp';\n\nexport function preloadUser(options?: { firebaseApp?: firebase.app.App }) {\n  // TODO: Find an alternative that doesn't break the rules of hooks (conditional hook call)\n  const firebaseApp = options?.firebaseApp || useFirebaseApp();\n\n  return preloadAuth({ firebaseApp }).then(auth => {\n    const result = preloadObservable(user(auth()), `auth:user:${firebaseApp.name}`);\n    return result.toPromise();\n  });\n}\n\n/**\n * Subscribe to Firebase auth state changes, including token refresh\n *\n * @param auth - the [firebase.auth](https://firebase.google.com/docs/reference/js/firebase.auth) object\n * @param options\n */\nexport function useUser<T = unknown>(auth?: firebase.auth.Auth, options?: ReactFireOptions<T>): ObservableStatus<firebase.User> {\n  // TODO: Find an alternative that doesn't break the rules of hooks (conditional hook call)\n  auth = auth || useAuth();\n\n  if (!auth) {\n    throw new Error('firebase.auth not found');\n  }\n\n  const observableId = `auth:user:${auth.app.name}`;\n  const observable$ = user(auth);\n\n  let currentUser = auth.currentUser;\n\n  // If currentUser is available, skip initialData\n  if (options?.initialData && !currentUser) {\n    currentUser = options.initialData;\n  }\n\n  return useObservable(observableId, observable$, { ...options, initialData: currentUser });\n}\n\nexport function useIdTokenResult(\n  user: firebase.User,\n  forceRefresh: boolean = false,\n  options?: ReactFireOptions<firebase.auth.IdTokenResult>\n): ObservableStatus<firebase.auth.IdTokenResult> {\n  if (!user) {\n    throw new Error('you must provide a user');\n  }\n\n  const observableId = `auth:idTokenResult:${user.uid}:forceRefresh=${forceRefresh}`;\n  const observable$ = from(user.getIdTokenResult(forceRefresh));\n\n  return useObservable(observableId, observable$, options);\n}\n\nexport interface AuthCheckProps {\n  auth?: firebase.auth.Auth;\n  fallback: React.ReactNode;\n  children: React.ReactNode;\n  requiredClaims?: Object;\n}\n\nexport interface ClaimsCheckProps {\n  user: firebase.User;\n  fallback: React.ReactNode;\n  children: React.ReactNode;\n  requiredClaims?: { [key: string]: any };\n}\n\nexport function ClaimsCheck({ user, fallback, children, requiredClaims }: ClaimsCheckProps) {\n  const { data } = useIdTokenResult(user, false);\n  const { claims } = data;\n  const missingClaims: { [key: string]: { expected: string; actual: string } } = {};\n\n  if (requiredClaims) {\n    Object.keys(requiredClaims).forEach(claim => {\n      if (requiredClaims[claim] !== claims[claim]) {\n        missingClaims[claim] = {\n          expected: requiredClaims[claim],\n          actual: claims[claim]\n        };\n      }\n    });\n  }\n\n  if (Object.keys(missingClaims).length === 0) {\n    return <>{children}</>;\n  } else {\n    return <>{fallback}</>;\n  }\n}\n\nexport function AuthCheck({ auth, fallback, children, requiredClaims }: AuthCheckProps): JSX.Element {\n  const { data: user } = useUser<firebase.User>(auth);\n\n  if (user) {\n    return requiredClaims ? (\n      <ClaimsCheck user={user} fallback={fallback} requiredClaims={requiredClaims}>\n        {children}\n      </ClaimsCheck>\n    ) : (\n      <>{children}</>\n    );\n  } else {\n    return <>{fallback}</>;\n  }\n}\n","import firebase from 'firebase/app';\nimport { list, object, QueryChange, listVal } from 'rxfire/database';\nimport { ReactFireOptions, useObservable, checkIdField, ObservableStatus, ReactFireGlobals } from './';\n\nimport { Observable } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\n// Since we're side-effect free, we need to ensure our observableId cache is global\nconst cachedQueries: Array<firebase.database.Query> = ((globalThis as any) as ReactFireGlobals)._reactFireDatabaseCachedQueries || [];\n\nif (!((globalThis as any) as ReactFireGlobals)._reactFireDatabaseCachedQueries) {\n  ((globalThis as any) as ReactFireGlobals)._reactFireDatabaseCachedQueries = cachedQueries;\n}\n\nfunction getUniqueIdForDatabaseQuery(query: firebase.database.Query) {\n  const index = cachedQueries.findIndex(cachedQuery => cachedQuery.isEqual(query));\n  if (index > -1) {\n    return index;\n  }\n  return cachedQueries.push(query) - 1;\n}\n\n/**\n * Subscribe to a Realtime Database object\n *\n * @param ref - Reference to the DB object you want to listen to\n * @param options\n */\nexport function useDatabaseObject<T = unknown>(ref: firebase.database.Reference, options?: ReactFireOptions<T>): ObservableStatus<QueryChange | T> {\n  const observableId = `database:object:${ref.toString()}`;\n  const observable$ = object(ref);\n\n  return useObservable(observableId, observable$, options);\n}\n\n// ============================================================================\n// TODO: switch to rxfire's objectVal once this PR is merged:\n// https://github.com/firebase/firebase-js-sdk/pull/2352\n\nfunction objectVal<T>(query: firebase.database.Query, keyField?: string): Observable<T> {\n  return object(query).pipe(map(change => changeToData(change, keyField) as T));\n}\n\nfunction changeToData(change: QueryChange, keyField?: string): {} {\n  const val = change.snapshot.val();\n\n  // don't worry about setting IDs if the value is a primitive type\n  if (typeof val !== 'object') {\n    return val;\n  }\n\n  return {\n    ...change.snapshot.val(),\n    ...(keyField ? { [keyField]: change.snapshot.key } : null)\n  };\n}\n// ============================================================================\n\nexport function useDatabaseObjectData<T>(ref: firebase.database.Reference, options?: ReactFireOptions<T>): ObservableStatus<T> {\n  const idField = options ? checkIdField(options) : 'NO_ID_FIELD';\n  const observableId = `database:objectVal:${ref.toString()}:idField=${idField}`;\n  const observable$ = objectVal(ref, idField);\n\n  return useObservable(observableId, observable$, options);\n}\n\n/**\n * Subscribe to a Realtime Database list\n *\n * @param ref - Reference to the DB List you want to listen to\n * @param options\n */\nexport function useDatabaseList<T = { [key: string]: unknown }>(\n  ref: firebase.database.Reference | firebase.database.Query,\n  options?: ReactFireOptions<T[]>\n): ObservableStatus<QueryChange[] | T[]> {\n  const hash = `database:list:${getUniqueIdForDatabaseQuery(ref)}`;\n  const observable$ = list(ref);\n\n  return useObservable(hash, observable$, options);\n}\n\nexport function useDatabaseListData<T = { [key: string]: unknown }>(\n  ref: firebase.database.Reference | firebase.database.Query,\n  options?: ReactFireOptions<T[]>\n): ObservableStatus<T[]> {\n  const idField = options ? checkIdField(options) : 'NO_ID_FIELD';\n  const observableId = `database:listVal:${getUniqueIdForDatabaseQuery(ref)}:idField=${idField}`;\n  const observable$ = listVal(ref, idField);\n  return useObservable(observableId, observable$, options);\n}\n","import { empty, Observable, Subject, Subscriber, Subscription } from 'rxjs';\nimport { catchError, shareReplay, tap } from 'rxjs/operators';\n\nexport class SuspenseSubject<T> extends Subject<T> {\n  private _value: T | undefined;\n  private _hasValue = false;\n  private _timeoutHandler: NodeJS.Timeout;\n  private _firstEmission: Promise<void>;\n  private _error: any = undefined;\n  private _innerObservable: Observable<T>;\n  private _warmupSubscription: Subscription;\n\n  // @ts-ignore: TODO: double check to see if this is an RXJS thing or if we should listen to TS\n  private _innerSubscriber: Subscription;\n  // @ts-ignore: TODO: double check to see if this is an RXJS thing or if we should listen to TS\n  private _resolveFirstEmission: () => void;\n\n  constructor(innerObservable: Observable<T>, private _timeoutWindow: number) {\n    super();\n    this._firstEmission = new Promise<void>(resolve => (this._resolveFirstEmission = resolve));\n    this._innerObservable = innerObservable.pipe(\n      tap(\n        v => {\n          this._next(v);\n        },\n        e => {\n          // save the error, so that we can raise on subscription or .value\n          // resolve the promise, so suspense tries again\n          this._error = e;\n          this._resolveFirstEmission();\n        }\n      ),\n      catchError(() => empty()),\n      shareReplay(1)\n    );\n    // warm up the observable\n    this._warmupSubscription = this._innerObservable.subscribe();\n\n    // set a timeout for reseting the cache, subscriptions will cancel the timeout\n    // and reschedule again on unsubscribe\n    this._timeoutHandler = setTimeout(this._reset, this._timeoutWindow);\n  }\n\n  get hasValue(): boolean {\n    // hasValue returns true if there's an error too\n    // so that after we resolve the promise & useObservable is called again\n    // we won't throw again\n    return this._hasValue || !!this._error;\n  }\n\n  get value(): T | undefined {\n    // TODO figure out how to reset the cache here, if I _reset() here before throwing\n    // it doesn't seem to work.\n    // As it is now, this will burn the cache entry until the timeout fires.\n    if (this._error) {\n      throw this._error;\n    }\n    return this._value;\n  }\n\n  get firstEmission(): Promise<void> {\n    return this._firstEmission;\n  }\n\n  private _next(value: T) {\n    this._hasValue = true;\n    this._value = value;\n    this._resolveFirstEmission();\n  }\n\n  private _reset() {\n    // seems to be undefined in tests?\n    if (this._warmupSubscription) {\n      this._warmupSubscription.unsubscribe();\n    }\n    this._hasValue = false;\n    this._value = undefined;\n    this._error = undefined;\n    this._firstEmission = new Promise<void>(resolve => (this._resolveFirstEmission = resolve));\n  }\n\n  _subscribe(subscriber: Subscriber<T>): Subscription {\n    if (this._timeoutHandler) {\n      clearTimeout(this._timeoutHandler);\n    }\n    this._innerSubscriber = this._innerObservable.subscribe(subscriber);\n    return this._innerSubscriber.add(this._reset);\n  }\n\n  get ourError() {\n    return this._error;\n  }\n}\n","import * as React from 'react';\nimport { Observable } from 'rxjs';\nimport { SuspenseSubject } from './SuspenseSubject';\nimport { useSuspenseEnabledFromConfigAndContext } from './firebaseApp';\nimport { ReactFireGlobals, ReactFireOptions } from './';\n\nconst DEFAULT_TIMEOUT = 30_000;\n\n// Since we're side-effect free, we need to ensure our observable cache is global\nconst preloadedObservables: Map<string, SuspenseSubject<any>> = ((globalThis as any) as ReactFireGlobals)._reactFirePreloadedObservables || new Map();\n\nif (!((globalThis as any) as ReactFireGlobals)._reactFirePreloadedObservables) {\n  ((globalThis as any) as ReactFireGlobals)._reactFirePreloadedObservables = preloadedObservables;\n}\n\n// Starts listening to an Observable.\n// Call this once you know you're going to render a\n// child that will consume the observable\nexport function preloadObservable<T>(source: Observable<T>, id: string) {\n  if (preloadedObservables.has(id)) {\n    return preloadedObservables.get(id) as SuspenseSubject<T>;\n  } else {\n    const observable = new SuspenseSubject(source, DEFAULT_TIMEOUT);\n    preloadedObservables.set(id, observable);\n    return observable;\n  }\n}\n\nexport interface ObservableStatus<T> {\n  status:\n    | 'loading' // waiting for first value from observable\n    | 'error'\n    | 'success'; // has received at least one value\n  hasEmitted: boolean; // has received at least one value\n  isComplete: boolean; // observable has triggered onComplete event\n  data: T; // latest data from observable\n  error: Error | undefined;\n  firstValuePromise: Promise<void>; // promise that resolves after first emit from observable\n}\n\nexport function useObservable<T>(observableId: string, source: Observable<T | any>, config: ReactFireOptions = {}): ObservableStatus<T> {\n  if (!observableId) {\n    throw new Error('cannot call useObservable without an observableId');\n  }\n  const observable = preloadObservable(source, observableId);\n\n  const hasInitialData = Object.keys(config).includes('initialData');\n\n  const suspenseEnabled = useSuspenseEnabledFromConfigAndContext(config.suspense);\n\n  if (!observable.hasValue && !config?.initialData) {\n    if (suspenseEnabled === true) {\n      throw observable.firstEmission;\n    }\n  }\n\n  const [latest, setValue] = React.useState(() => (observable.hasValue ? observable.value : config.initialData));\n  React.useEffect(() => {\n    const subscription = observable.subscribe(\n      v => {\n        setValue(() => v);\n      },\n      e => {\n        throw e;\n      }\n    );\n    return () => subscription.unsubscribe();\n  }, [observable]);\n\n  let status: ObservableStatus<T>['status'];\n\n  if (observable.hasError) {\n    status = 'error';\n  } else if (observable.hasValue || hasInitialData) {\n    status = 'success';\n  } else {\n    status = 'loading';\n  }\n\n  return {\n    status,\n    hasEmitted: observable.hasValue,\n    isComplete: observable.isStopped,\n    data: latest,\n    error: observable.ourError,\n    firstValuePromise: observable.firstEmission\n  };\n}\n","import firebase from 'firebase/app';\nimport { collectionData, doc, docData, fromCollectionRef } from 'rxfire/firestore';\nimport { preloadFirestore, ReactFireOptions, useObservable, checkIdField, ReactFireGlobals } from './';\nimport { preloadObservable, ObservableStatus } from './useObservable';\nimport { first } from 'rxjs/operators';\nimport { useFirebaseApp } from './firebaseApp';\n\n// Since we're side-effect free, we need to ensure our observableId cache is global\nconst cachedQueries: Array<firebase.firestore.Query> = ((globalThis as any) as ReactFireGlobals)._reactFireFirestoreQueryCache || [];\n\nif (!((globalThis as any) as ReactFireGlobals)._reactFireFirestoreQueryCache) {\n  ((globalThis as any) as ReactFireGlobals)._reactFireFirestoreQueryCache = cachedQueries;\n}\n\nfunction getUniqueIdForFirestoreQuery(query: firebase.firestore.Query) {\n  const index = cachedQueries.findIndex(cachedQuery => cachedQuery.isEqual(query));\n  if (index > -1) {\n    return index;\n  }\n  return cachedQueries.push(query) - 1;\n}\n\n// starts a request for a firestore doc.\n// imports the firestore SDK automatically\n// if it hasn't been imported yet.\n//\n// there's a decent chance this gets called before the Firestore SDK\n// has been imported, so it takes a refProvider instead of a ref\nexport function preloadFirestoreDoc(\n  refProvider: (firestore: firebase.firestore.Firestore) => firebase.firestore.DocumentReference,\n  options?: { firebaseApp?: firebase.app.App }\n) {\n  // TODO: Find an alternative that doesn't break the rules of hooks (conditional hook call)\n  const firebaseApp = options?.firebaseApp || useFirebaseApp();\n\n  return preloadFirestore({ firebaseApp }).then(firestore => {\n    const ref = refProvider(firestore());\n    return preloadObservable(doc(ref), `firestore:doc:${firebaseApp.name}:${ref.path}`);\n  });\n}\n\n/**\n * Suscribe to Firestore Document changes\n *\n * @param ref - Reference to the document you want to listen to\n * @param options\n */\nexport function useFirestoreDoc<T = unknown>(\n  ref: firebase.firestore.DocumentReference,\n  options?: ReactFireOptions<T>\n): ObservableStatus<T extends {} ? T : firebase.firestore.DocumentSnapshot> {\n  const observableId = `firestore:doc:${ref.firestore.app.name}:${ref.path}`;\n  const observable$ = doc(ref);\n\n  return useObservable(observableId, observable$, options);\n}\n\n/**\n * Get a firestore document and don't subscribe to changes\n *\n * @param ref - Reference to the document you want to get\n * @param options\n */\nexport function useFirestoreDocOnce<T = unknown>(\n  ref: firebase.firestore.DocumentReference,\n  options?: ReactFireOptions<T>\n): ObservableStatus<T extends {} ? T : firebase.firestore.DocumentSnapshot> {\n  const observableId = `firestore:docOnce:${ref.firestore.app.name}:${ref.path}`;\n  const observable$ = doc(ref).pipe(first());\n\n  return useObservable(observableId, observable$, options);\n}\n\n/**\n * Suscribe to Firestore Document changes\n *\n * @param ref - Reference to the document you want to listen to\n * @param options\n */\nexport function useFirestoreDocData<T>(ref: firebase.firestore.DocumentReference, options?: ReactFireOptions<T>): ObservableStatus<T> {\n  const idField = options ? checkIdField(options) : 'NO_ID_FIELD';\n\n  const observableId = `firestore:docData:${ref.firestore.app.name}:${ref.path}:idField=${idField}`;\n  const observable = docData(ref, idField);\n\n  return useObservable(observableId, observable, options);\n}\n\n/**\n * Get a firestore document and don't subscribe to changes\n *\n * @param ref - Reference to the document you want to get\n * @param options\n */\nexport function useFirestoreDocDataOnce<T = unknown>(ref: firebase.firestore.DocumentReference, options?: ReactFireOptions<T>): ObservableStatus<T> {\n  const idField = options ? checkIdField(options) : 'NO_ID_FIELD';\n\n  const observableId = `firestore:docDataOnce:${ref.firestore.app.name}:${ref.path}:idField=${idField}`;\n  const observable$ = docData(ref, idField).pipe(first());\n\n  return useObservable(observableId, observable$, options);\n}\n\n/**\n * Subscribe to a Firestore collection\n *\n * @param ref - Reference to the collection you want to listen to\n * @param options\n */\nexport function useFirestoreCollection<T = { [key: string]: unknown }>(\n  query: firebase.firestore.Query,\n  options?: ReactFireOptions<T[]>\n): ObservableStatus<T extends {} ? T[] : firebase.firestore.QuerySnapshot> {\n  const observableId = `firestore:collection:${getUniqueIdForFirestoreQuery(query)}`;\n  const observable$ = fromCollectionRef(query);\n\n  return useObservable(observableId, observable$, options);\n}\n\n/**\n * Subscribe to a Firestore collection and unwrap the snapshot.\n *\n * @param ref - Reference to the collection you want to listen to\n * @param options\n */\nexport function useFirestoreCollectionData<T = { [key: string]: unknown }>(\n  query: firebase.firestore.Query,\n  options?: ReactFireOptions<T[]>\n): ObservableStatus<T[]> {\n  const idField = options ? checkIdField(options) : 'NO_ID_FIELD';\n  const observableId = `firestore:collectionData:${getUniqueIdForFirestoreQuery(query)}:idField=${idField}`;\n  const observable$ = collectionData(query, idField);\n\n  return useObservable(observableId, observable$, options);\n}\n","import { Observable } from 'rxjs';\n\ntype RemoteConfig = import('firebase/app').default.remoteConfig.RemoteConfig;\ntype RemoteConfigValue = import('firebase/app').default.remoteConfig.Value;\n\nexport type AllParameters = {\n  [key: string]: RemoteConfigValue;\n};\n\ninterface ParameterSettings<T> {\n  remoteConfig: RemoteConfig;\n  key: string;\n  getter: (key: string) => T;\n}\n\n// TODO(davideast): Replace with RxFire functions when they land\nfunction parameter$<T>({ remoteConfig, key, getter }: ParameterSettings<T>): Observable<T> {\n  return new Observable(subscriber => {\n    remoteConfig.ensureInitialized().then(() => {\n      // 'this' for the getter loses context in the next()\n      // call, so it needs to be bound.\n      subscriber.next(getter.bind(remoteConfig)(key));\n    });\n  });\n}\n\nexport function getValue(remoteConfig: RemoteConfig, key: string) {\n  const getter = remoteConfig.getValue;\n  return parameter$({ remoteConfig, key, getter });\n}\n\nexport function getString(remoteConfig: RemoteConfig, key: string) {\n  const getter = remoteConfig.getString;\n  return parameter$<string>({ remoteConfig, key, getter });\n}\n\nexport function getNumber(remoteConfig: RemoteConfig, key: string) {\n  const getter = remoteConfig.getNumber;\n  return parameter$<number>({ remoteConfig, key, getter });\n}\n\nexport function getBoolean(remoteConfig: RemoteConfig, key: string) {\n  const getter = remoteConfig.getBoolean;\n  return parameter$<boolean>({ remoteConfig, key, getter });\n}\n\nexport function getAll(remoteConfig: RemoteConfig) {\n  const getter = remoteConfig.getAll;\n  // No key is needed for getAll()\n  return parameter$<AllParameters>({ remoteConfig, key: '', getter });\n}\n","import { useRemoteConfig } from '../firebaseApp';\nimport { useObservable, ObservableStatus } from '../useObservable';\nimport { getValue, getString, getBoolean, getNumber, getAll, AllParameters } from './getValue';\nimport { Observable } from 'rxjs';\n\ntype RemoteConfig = import('firebase/app').default.remoteConfig.RemoteConfig;\ntype RemoteConfigValue = import('firebase/app').default.remoteConfig.Value;\ntype Getter$<T> = (remoteConfig: RemoteConfig, key: string) => Observable<T>;\n\ninterface RemoteConfigWithPrivate extends RemoteConfig {\n  // This is a private API, assume optional\n  _storage?: { appName: string };\n}\n\n/**\n * Helper function to construct type safe functions. Since Remote Config has\n * methods that return different types for values, we need to be extra safe\n * to make sure we are not returning improper types by accident.\n * @param key\n * @param getter\n * @param remoteConfig\n */\nfunction useRemoteConfigValue_INTERNAL<T>(key: string, getter: Getter$<T>, remoteConfig?: RemoteConfig): ObservableStatus<T> {\n  // TODO: Find an alternative that doesn't break the rules of hooks (conditional hook call)\n  remoteConfig = remoteConfig || useRemoteConfig();\n\n  // INVESTIGATE need to use a public API to get at the app name, one doesn't appear to exist...\n  // we might need to iterate over the Firebase apps and check for remoteConfig equality? this works for now\n  const appName = (remoteConfig as RemoteConfigWithPrivate)._storage?.appName;\n  const $value = getter(remoteConfig, key);\n\n  const observableId = `remoteConfig:${key}:${getter.name}:${appName}`;\n  return useObservable<T>(observableId, $value);\n}\n\n/**\n * Accepts a key and optionally a Remote Config instance. Returns a\n * Remote Config Value.\n *\n * @param key The parameter key in Remote Config\n * @param remoteConfig Optional instance. If not provided ReactFire will either grab the default instance or lazy load.\n */\nexport function useRemoteConfigValue(key: string, remoteConfig?: RemoteConfig): ObservableStatus<RemoteConfigValue> {\n  return useRemoteConfigValue_INTERNAL<RemoteConfigValue>(key, getValue, remoteConfig);\n}\n\n/**\n * Convience method similar to useRemoteConfigValue. Returns a `string` from a Remote Config parameter.\n * @param key The parameter key in Remote Config\n * @param remoteConfig Optional instance. If not provided ReactFire will either grab the default instance or lazy load.\n */\nexport function useRemoteConfigString(key: string, remoteConfig?: RemoteConfig): ObservableStatus<string> {\n  return useRemoteConfigValue_INTERNAL<string>(key, getString, remoteConfig);\n}\n\n/**\n * Convience method similar to useRemoteConfigValue. Returns a `number` from a Remote Config parameter.\n * @param key The parameter key in Remote Config\n * @param remoteConfig Optional instance. If not provided ReactFire will either grab the default instance or lazy load.\n */\nexport function useRemoteConfigNumber(key: string, remoteConfig?: RemoteConfig): ObservableStatus<number> {\n  return useRemoteConfigValue_INTERNAL<number>(key, getNumber, remoteConfig);\n}\n\n/**\n * Convience method similar to useRemoteConfigValue. Returns a `boolean` from a Remote Config parameter.\n * @param key The parameter key in Remote Config\n * @param remoteConfig Optional instance. If not provided ReactFire will either grab the default instance or lazy load.\n */\nexport function useRemoteConfigBoolean(key: string, remoteConfig?: RemoteConfig): ObservableStatus<boolean> {\n  return useRemoteConfigValue_INTERNAL<boolean>(key, getBoolean, remoteConfig);\n}\n\n/**\n * Convience method similar to useRemoteConfigValue. Returns allRemote Config parameters.\n * @param key The parameter key in Remote Config\n * @param remoteConfig Optional instance. If not provided ReactFire will either grab the default instance or lazy load.\n */\nexport function useRemoteConfigAll(key: string, remoteConfig?: RemoteConfig): ObservableStatus<AllParameters> {\n  return useRemoteConfigValue_INTERNAL<AllParameters>(key, getAll, remoteConfig);\n}\n","import firebase from 'firebase/app';\nimport * as React from 'react';\nimport { getDownloadURL } from 'rxfire/storage';\nimport { Observable } from 'rxjs';\nimport { ReactFireOptions, useObservable, ObservableStatus } from './';\nimport { useStorage, useSuspenseEnabledFromConfigAndContext } from './firebaseApp';\n\n/**\n * modified version of rxFire's _fromTask\n *\n * @param task\n */\nfunction _fromTask(task: firebase.storage.UploadTask) {\n  return new Observable<firebase.storage.UploadTaskSnapshot>(subscriber => {\n    const progress = (snap: firebase.storage.UploadTaskSnapshot) => {\n      return subscriber.next(snap);\n    };\n    const error = (e: any) => subscriber.error(e);\n    const complete = () => {\n      return subscriber.complete();\n    };\n    task.on('state_changed', progress, error, complete);\n\n    // I REMOVED THE UNSUBSCRIBE RETURN BECAUSE IT CANCELS THE UPLOAD\n    // https://github.com/firebase/firebase-js-sdk/issues/1659\n  });\n}\n\n/**\n * Subscribe to the progress of a storage task\n *\n * @param task - the task you want to listen to\n * @param ref - reference to the blob the task is acting on\n * @param options\n */\nexport function useStorageTask<T = unknown>(\n  task: firebase.storage.UploadTask,\n  ref: firebase.storage.Reference,\n  options?: ReactFireOptions<T>\n): ObservableStatus<firebase.storage.UploadTaskSnapshot | T> {\n  const observableId = `storage:task:${ref.toString()}`;\n  const observable$ = _fromTask(task);\n\n  return useObservable(observableId, observable$, options ? options.initialData : undefined);\n}\n\n/**\n * Subscribe to a storage ref's download URL\n *\n * @param ref - reference to the blob you want to download\n * @param options\n */\nexport function useStorageDownloadURL<T = string>(ref: firebase.storage.Reference, options?: ReactFireOptions<T>): ObservableStatus<string | T> {\n  const observableId = `storage:downloadUrl:${ref.toString()}`;\n  const observable$ = getDownloadURL(ref);\n\n  return useObservable(observableId, observable$, options);\n}\n\ntype StorageImageProps = {\n  storagePath: string;\n  storage?: firebase.storage.Storage;\n  suspense?: boolean;\n  placeHolder?: JSX.Element;\n};\n\nfunction StorageFromContext(props: StorageImageProps & React.DetailedHTMLProps<React.ImgHTMLAttributes<HTMLImageElement>, HTMLImageElement>) {\n  const storage = useStorage();\n\n  props = { ...props, storage };\n\n  return <INTERNALStorageImage {...props} />;\n}\n\nfunction INTERNALStorageImage(props: StorageImageProps & React.DetailedHTMLProps<React.ImgHTMLAttributes<HTMLImageElement>, HTMLImageElement>): JSX.Element {\n  let { storage, storagePath, suspense, placeHolder, ...imgProps } = props;\n\n  const reactfireOptions: ReactFireOptions<string> = {\n    suspense: useSuspenseEnabledFromConfigAndContext(suspense)\n  };\n\n  if (!storage) {\n    throw new Error('Storage was not passed to component INTERNALStorageImage. This should not be possible');\n  }\n\n  const { status, data: imgSrc } = useStorageDownloadURL(storage.ref(storagePath), reactfireOptions);\n\n  if (status === 'success') {\n    if (!(imgProps.alt || imgProps.alt === '')) {\n      console.warn(\n        `No alt prop provided for StorageImage with storagePath \"${storagePath}\"`,\n        'img elements must have an alt prop, either with meaningful text, or an empty string for decorative images'\n      );\n    }\n\n    return <img src={imgSrc} alt={imgProps.alt} {...imgProps} />;\n  } else {\n    return placeHolder ?? <>''</>;\n  }\n}\n\nexport function StorageImage(props: StorageImageProps & React.DetailedHTMLProps<React.ImgHTMLAttributes<HTMLImageElement>, HTMLImageElement>) {\n  let { storage } = props;\n\n  if (storage) {\n    return <INTERNALStorageImage {...props} />;\n  } else {\n    return <StorageFromContext {...props} />;\n  }\n}\n","import firebase from 'firebase/app';\nimport { SuspenseSubject } from './SuspenseSubject';\n\nexport type ReactFireGlobals = {\n  _reactFireDatabaseCachedQueries: Array<firebase.database.Query>;\n  _reactFireFirestoreQueryCache: Array<firebase.firestore.Query>;\n  _reactFirePreloadedObservables: Map<string, SuspenseSubject<any>>;\n};\n\nexport interface ReactFireOptions<T = unknown> {\n  idField?: string;\n  initialData?: T | any;\n  suspense?: boolean;\n}\n\nexport function checkOptions(options: ReactFireOptions, field: string) {\n  // make sure the field passed in is a valid key of ReactFire Options\n  if (field === 'idField' || field === 'initialData' || field === 'suspense') {\n    return options ? (options[field] as ReactFireOptions['idField'] | ReactFireOptions['initialData'] | ReactFireOptions['suspense']) : undefined;\n  }\n\n  throw new Error(`Field \"${field}\" is not a valid key in ReactFireOptions`);\n}\n\nexport function checkinitialData(options: ReactFireOptions) {\n  return checkOptions(options, 'initialData');\n}\n\nexport function checkIdField(options: ReactFireOptions) {\n  return checkOptions(options, 'idField');\n}\n\nexport * from './auth';\nexport * from './database';\nexport * from './firebaseApp';\nexport * from './firestore';\nexport * from './performance';\nexport * from './remote-config';\nexport * from './storage';\nexport * from './useObservable';\n","import * as React from 'react';\nimport { preloadPerformance } from './';\nimport { useFirebaseApp } from './firebaseApp';\n\nexport interface SuspensePerfProps {\n  children: React.ReactNode;\n  traceId: string;\n  fallback: React.ReactNode;\n  firePerf?: import('firebase/app').default.performance.Performance;\n}\n\nexport function SuspenseWithPerf({ children, traceId, fallback, firePerf }: SuspensePerfProps): JSX.Element {\n  if (!firePerf) {\n    const firebaseApp = useFirebaseApp();\n    preloadPerformance({ firebaseApp }).then(perf => perf());\n  }\n\n  const entries = performance?.getEntriesByName(traceId, 'measure') || [];\n  const startMarkName = `_${traceId}Start[${entries.length}]`;\n  const endMarkName = `_${traceId}End[${entries.length}]`;\n\n  const Fallback = () => {\n    React.useLayoutEffect(() => {\n      performance?.mark(startMarkName);\n\n      return () => {\n        performance?.mark(endMarkName);\n        performance?.measure(traceId, startMarkName, endMarkName);\n      };\n    }, []);\n\n    return <>{fallback}</>;\n  };\n\n  return <React.Suspense fallback={<Fallback />}>{children}</React.Suspense>;\n}\n"],"names":["proxyComponent","componentName","contextualApp","Proxy","app","suspense","useFirebaseApp","suspenseEnabled","useSuspenseEnabledFromConfigAndContext","sdkSubject","preload","hasValue","firstEmission","firebase","Error","charAt","toUpperCase","slice","get","target","p","apply","_this","args","component","bind","useAuth","useAnalytics","useDatabase","useFirestore","useFunctions","useMessaging","usePerformance","useRemoteConfig","useStorage","auth","analytics","database","firestore","functions","messaging","performance","remoteConfig","storage","preloadFactory","options","firebaseApp","setup","toPromise","settingsCallback","preloadObservable","Observable","emitter","sdk","importSDK","then","instanceFactory","Promise","resolve","next","complete","e","error","name","preloadAuth","preloadAnalytics","preloadDatabase","preloadFirestore","preloadFunctions","preloadMessaging","preloadPerformance","preloadRemoteConfig","preloadStorage","FirebaseAppContext","React","undefined","SuspenseEnabledContext","suspenseFromConfig","suspenseFromContext","useUser","observableId","observable$","user","currentUser","initialData","useObservable","useIdTokenResult","forceRefresh","uid","from","getIdTokenResult","ClaimsCheck","fallback","children","requiredClaims","claims","data","missingClaims","Object","keys","forEach","claim","expected","actual","length","cachedQueries","globalThis","_reactFireDatabaseCachedQueries","getUniqueIdForDatabaseQuery","query","index","findIndex","cachedQuery","isEqual","push","SuspenseSubject","innerObservable","_timeoutWindow","_firstEmission","_resolveFirstEmission","_innerObservable","pipe","tap","v","_next","_error","catchError","empty","shareReplay","_warmupSubscription","subscribe","_timeoutHandler","setTimeout","_reset","value","_hasValue","_value","this","unsubscribe","_this2","_subscribe","subscriber","clearTimeout","_innerSubscriber","add","Subject","preloadedObservables","_reactFirePreloadedObservables","Map","source","id","has","observable","set","config","hasInitialData","includes","_config","latest","setValue","subscription","status","hasError","hasEmitted","isComplete","isStopped","ourError","firstValuePromise","_reactFireFirestoreQueryCache","getUniqueIdForFirestoreQuery","parameter$","key","getter","ensureInitialized","getValue","getString","getNumber","getBoolean","getAll","useRemoteConfigValue_INTERNAL","appName","_storage","_remoteConfig$_storag","$value","useStorageDownloadURL","ref","toString","getDownloadURL","StorageFromContext","props","INTERNALStorageImage","storagePath","placeHolder","imgProps","reactfireOptions","imgSrc","alt","console","warn","src","checkOptions","field","checkIdField","firebaseConfig","a","b","existingApp","apps","find","every","registerVersion","initializeApp","Provider","traceId","firePerf","perf","entries","getEntriesByName","startMarkName","endMarkName","mark","measure","refProvider","doc","path","list","idField","listVal","object","keyField","map","change","val","snapshot","changeToData","fromCollectionRef","collectionData","docData","first","task","on","snap","_fromTask"],"mappings":"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"}