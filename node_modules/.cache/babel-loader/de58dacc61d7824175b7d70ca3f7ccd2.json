{"ast":null,"code":"import { useMemo, createElement, useContext, createContext, version as version$1, Fragment, useState, useEffect, Suspense, useLayoutEffect } from 'react';\nimport { user } from 'rxfire/auth';\nimport { Observable, from, empty, Subject } from 'rxjs';\nimport firebase from 'firebase/app';\nimport { object, list, listVal } from 'rxfire/database';\nimport { map, tap, catchError, shareReplay, first } from 'rxjs/operators';\nimport { doc, docData, fromCollectionRef, collectionData } from 'rxfire/firestore';\nimport { getDownloadURL } from 'rxfire/storage';\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction importSDK(sdk) {\n  switch (sdk) {\n    case 'analytics':\n      return import(\n      /* webpackChunkName: \"analytics\" */\n      'firebase/analytics');\n\n    case 'auth':\n      return import(\n      /* webpackChunkName: \"auth\" */\n      'firebase/auth');\n\n    case 'database':\n      return import(\n      /* webpackChunkName: \"database\" */\n      'firebase/database');\n\n    case 'firestore':\n      return import(\n      /* webpackChunkName: \"firestore\" */\n      'firebase/firestore');\n\n    case 'functions':\n      return import(\n      /* webpackChunkName: \"functions\" */\n      'firebase/functions');\n\n    case 'messaging':\n      return import(\n      /* webpackChunkName: \"messaging\" */\n      'firebase/messaging');\n\n    case 'performance':\n      return import(\n      /* webpackChunkName: \"performance\" */\n      'firebase/performance');\n\n    case 'remoteConfig':\n      return import(\n      /* webpackChunkName: \"remoteConfig\" */\n      'firebase/remote-config');\n\n    case 'storage':\n      return import(\n      /* webpackChunkName: \"storage\" */\n      'firebase/storage');\n  }\n}\n\nfunction proxyComponent(componentName) {\n  var contextualApp;\n\n  var useComponent = function useComponent(app, suspense) {\n    contextualApp = useFirebaseApp();\n    var suspenseEnabled = useSuspenseEnabledFromConfigAndContext(suspense);\n    var sdkSubject = preload(componentName, app || contextualApp);\n\n    if (!sdkSubject.hasValue && suspenseEnabled) {\n      throw sdkSubject.firstEmission;\n    } else if (!sdkSubject.hasValue && !suspenseEnabled && !firebase[componentName]) {\n      throw new Error(\"ReactFire: \\\"firebase/\" + componentName + \"\\\" not found. Please import it in your component, or call preload\" + (componentName.charAt(0).toUpperCase() + componentName.slice(1)) + \" and wait for it to resolve. ReactFire can only auto-import Firebase libraries if Suspense mode is enabled.\");\n    } // get value to throw if there's an error\n\n\n    return firebase[componentName];\n  };\n\n  return new Proxy(useComponent, {\n    // @ts-ignore: TODO: Fix the types here\n    get: function get(target, p) {\n      return target()[p];\n    },\n    apply: function apply(target, _this, args) {\n      var component = target(args[0]).bind(_this); // If they don't pass an app, assume the app in context rather than [DEFAULT]\n\n      if (!args[0]) {\n        args[0] = contextualApp;\n      }\n\n      return component.apply(void 0, args);\n    }\n  });\n}\n\nvar useAuth = /*#__PURE__*/proxyComponent('auth');\nvar useAnalytics = /*#__PURE__*/proxyComponent('analytics');\nvar useDatabase = /*#__PURE__*/proxyComponent('database');\nvar useFirestore = /*#__PURE__*/proxyComponent('firestore');\nvar useFunctions = /*#__PURE__*/proxyComponent('functions');\nvar useMessaging = /*#__PURE__*/proxyComponent('messaging');\nvar usePerformance = /*#__PURE__*/proxyComponent('performance');\nvar useRemoteConfig = /*#__PURE__*/proxyComponent('remoteConfig');\nvar useStorage = /*#__PURE__*/proxyComponent('storage');\nvar auth = useAuth;\nvar analytics = useAnalytics;\nvar database = useDatabase;\nvar firestore = useFirestore;\nvar functions = useFunctions;\nvar messaging = useMessaging;\nvar performance$1 = usePerformance;\nvar remoteConfig = useRemoteConfig;\nvar storage = useStorage;\n\nfunction preloadFactory(componentName) {\n  return function (options) {\n    return preload(componentName, options.firebaseApp, options.setup).toPromise();\n  };\n}\n\nfunction preload(componentName, firebaseApp, settingsCallback) {\n  if (settingsCallback === void 0) {\n    settingsCallback = function settingsCallback() {};\n  }\n\n  var app = firebaseApp;\n  return preloadObservable(new Observable(function (emitter) {\n    importSDK(componentName).then(function () {\n      var instanceFactory = app[componentName].bind(app);\n      Promise.resolve(settingsCallback(instanceFactory)).then(function () {\n        emitter.next(instanceFactory);\n        emitter.complete();\n      });\n    })[\"catch\"](function (e) {\n      emitter.error(e);\n      emitter.complete();\n    });\n  }), \"firebase-sdk:\" + componentName + \":\" + app.name);\n}\n\nvar preloadAuth = /*#__PURE__*/preloadFactory('auth');\nvar preloadAnalytics = /*#__PURE__*/preloadFactory('analytics');\nvar preloadDatabase = /*#__PURE__*/preloadFactory('database');\nvar preloadFirestore = /*#__PURE__*/preloadFactory('firestore');\nvar preloadFunctions = /*#__PURE__*/preloadFactory('functions');\nvar preloadMessaging = /*#__PURE__*/preloadFactory('messaging');\nvar preloadPerformance = /*#__PURE__*/preloadFactory('performance');\nvar preloadRemoteConfig = /*#__PURE__*/preloadFactory('remoteConfig');\nvar preloadStorage = /*#__PURE__*/preloadFactory('storage');\nvar DEFAULT_APP_NAME = '[DEFAULT]';\nvar FirebaseAppContext = /*#__PURE__*/createContext(undefined);\nvar SuspenseEnabledContext = /*#__PURE__*/createContext(false); // @ts-ignore: \"__REACTFIRE_VERSION__\" is replaced with actual ReactFire version (see babel.config.js)\n\nvar version = \"3.0.0-rc.0\";\n\nvar shallowEq = function shallowEq(a, b) {\n  return a === b || [].concat(Object.keys(a), Object.keys(b)).every(function (key) {\n    return a[key] === b[key];\n  });\n};\n\nfunction FirebaseAppProvider(props) {\n  var firebaseConfig = props.firebaseConfig,\n      appName = props.appName,\n      suspense = props.suspense;\n  var firebaseApp = useMemo(function () {\n    if (props.firebaseApp) {\n      return props.firebaseApp;\n    }\n\n    var existingApp = firebase.apps.find(function (app) {\n      return app.name === (appName || DEFAULT_APP_NAME);\n    });\n\n    if (existingApp) {\n      if (firebaseConfig && shallowEq(existingApp.options, firebaseConfig)) {\n        return existingApp;\n      } else {\n        throw new Error(\"Does not match the options already provided to the \" + (appName || 'default') + \" firebase app instance, give this new instance a different appName.\");\n      }\n    } else {\n      if (!firebaseConfig) {\n        throw new Error('No firebaseConfig provided');\n      } // TODO: DOUBLE CHECK THAT THIS GETS CALLED\n\n\n      var reactVersion = version$1 || 'unknown';\n      firebase.registerVersion('react', reactVersion);\n      firebase.registerVersion('reactfire', version);\n      return firebase.initializeApp(firebaseConfig, appName);\n    }\n  }, [props.firebaseApp, firebaseConfig, appName]);\n  return createElement(FirebaseAppContext.Provider, {\n    value: firebaseApp\n  }, createElement(SuspenseEnabledContext.Provider, Object.assign({\n    value: suspense != null ? suspense : false\n  }, props)));\n}\n\nfunction useIsSuspenseEnabled() {\n  var suspense = useContext(SuspenseEnabledContext); // default to false if not available in context\n\n  return suspense != null ? suspense : false;\n}\n\nfunction useSuspenseEnabledFromConfigAndContext(suspenseFromConfig) {\n  var suspenseFromContext = useContext(SuspenseEnabledContext); // prioritize config over context\n\n  if (suspenseFromConfig !== undefined) {\n    return suspenseFromConfig;\n  }\n\n  return suspenseFromContext;\n}\n\nfunction useFirebaseApp() {\n  var firebaseApp = useContext(FirebaseAppContext);\n\n  if (!firebaseApp) {\n    throw new Error('Cannot call useFirebaseApp unless your component is within a FirebaseAppProvider');\n  }\n\n  return firebaseApp;\n}\n\nfunction preloadUser(options) {\n  // TODO: Find an alternative that doesn't break the rules of hooks (conditional hook call)\n  var firebaseApp = (options == null ? void 0 : options.firebaseApp) || useFirebaseApp();\n  return preloadAuth({\n    firebaseApp: firebaseApp\n  }).then(function (auth) {\n    var result = preloadObservable(user(auth()), \"auth:user:\" + firebaseApp.name);\n    return result.toPromise();\n  });\n}\n/**\r\n * Subscribe to Firebase auth state changes, including token refresh\r\n *\r\n * @param auth - the [firebase.auth](https://firebase.google.com/docs/reference/js/firebase.auth) object\r\n * @param options\r\n */\n\n\nfunction useUser(auth, options) {\n  // TODO: Find an alternative that doesn't break the rules of hooks (conditional hook call)\n  auth = auth || useAuth();\n\n  if (!auth) {\n    throw new Error('firebase.auth not found');\n  }\n\n  var observableId = \"auth:user:\" + auth.app.name;\n  var observable$ = user(auth);\n  var currentUser = auth.currentUser; // If currentUser is available, skip initialData\n\n  if ((options == null ? void 0 : options.initialData) && !currentUser) {\n    currentUser = options.initialData;\n  }\n\n  return useObservable(observableId, observable$, _extends({}, options, {\n    initialData: currentUser\n  }));\n}\n\nfunction useIdTokenResult(user, forceRefresh, options) {\n  if (forceRefresh === void 0) {\n    forceRefresh = false;\n  }\n\n  if (!user) {\n    throw new Error('you must provide a user');\n  }\n\n  var observableId = \"auth:idTokenResult:\" + user.uid + \":forceRefresh=\" + forceRefresh;\n  var observable$ = from(user.getIdTokenResult(forceRefresh));\n  return useObservable(observableId, observable$, options);\n}\n\nfunction ClaimsCheck(_ref) {\n  var user = _ref.user,\n      fallback = _ref.fallback,\n      children = _ref.children,\n      requiredClaims = _ref.requiredClaims;\n\n  var _useIdTokenResult = useIdTokenResult(user, false),\n      data = _useIdTokenResult.data;\n\n  var claims = data.claims;\n  var missingClaims = {};\n\n  if (requiredClaims) {\n    Object.keys(requiredClaims).forEach(function (claim) {\n      if (requiredClaims[claim] !== claims[claim]) {\n        missingClaims[claim] = {\n          expected: requiredClaims[claim],\n          actual: claims[claim]\n        };\n      }\n    });\n  }\n\n  if (Object.keys(missingClaims).length === 0) {\n    return createElement(Fragment, null, children);\n  } else {\n    return createElement(Fragment, null, fallback);\n  }\n}\n\nfunction AuthCheck(_ref2) {\n  var auth = _ref2.auth,\n      fallback = _ref2.fallback,\n      children = _ref2.children,\n      requiredClaims = _ref2.requiredClaims;\n\n  var _useUser = useUser(auth),\n      user = _useUser.data;\n\n  if (user) {\n    return requiredClaims ? createElement(ClaimsCheck, {\n      user: user,\n      fallback: fallback,\n      requiredClaims: requiredClaims\n    }, children) : createElement(Fragment, null, children);\n  } else {\n    return createElement(Fragment, null, fallback);\n  }\n}\n\nvar cachedQueries = globalThis._reactFireDatabaseCachedQueries || [];\n\nif (!globalThis._reactFireDatabaseCachedQueries) {\n  globalThis._reactFireDatabaseCachedQueries = cachedQueries;\n}\n\nfunction getUniqueIdForDatabaseQuery(query) {\n  var index = cachedQueries.findIndex(function (cachedQuery) {\n    return cachedQuery.isEqual(query);\n  });\n\n  if (index > -1) {\n    return index;\n  }\n\n  return cachedQueries.push(query) - 1;\n}\n/**\r\n * Subscribe to a Realtime Database object\r\n *\r\n * @param ref - Reference to the DB object you want to listen to\r\n * @param options\r\n */\n\n\nfunction useDatabaseObject(ref, options) {\n  var observableId = \"database:object:\" + ref.toString();\n  var observable$ = object(ref);\n  return useObservable(observableId, observable$, options);\n} // ============================================================================\n// TODO: switch to rxfire's objectVal once this PR is merged:\n// https://github.com/firebase/firebase-js-sdk/pull/2352\n\n\nfunction objectVal(query, keyField) {\n  return object(query).pipe(map(function (change) {\n    return changeToData(change, keyField);\n  }));\n}\n\nfunction changeToData(change, keyField) {\n  var _ref;\n\n  var val = change.snapshot.val(); // don't worry about setting IDs if the value is a primitive type\n\n  if (typeof val !== 'object') {\n    return val;\n  }\n\n  return _extends({}, change.snapshot.val(), keyField ? (_ref = {}, _ref[keyField] = change.snapshot.key, _ref) : null);\n} // ============================================================================\n\n\nfunction useDatabaseObjectData(ref, options) {\n  var idField = options ? checkIdField(options) : 'NO_ID_FIELD';\n  var observableId = \"database:objectVal:\" + ref.toString() + \":idField=\" + idField;\n  var observable$ = objectVal(ref, idField);\n  return useObservable(observableId, observable$, options);\n}\n/**\r\n * Subscribe to a Realtime Database list\r\n *\r\n * @param ref - Reference to the DB List you want to listen to\r\n * @param options\r\n */\n\n\nfunction useDatabaseList(ref, options) {\n  var hash = \"database:list:\" + getUniqueIdForDatabaseQuery(ref);\n  var observable$ = list(ref);\n  return useObservable(hash, observable$, options);\n}\n\nfunction useDatabaseListData(ref, options) {\n  var idField = options ? checkIdField(options) : 'NO_ID_FIELD';\n  var observableId = \"database:listVal:\" + getUniqueIdForDatabaseQuery(ref) + \":idField=\" + idField;\n  var observable$ = listVal(ref, idField);\n  return useObservable(observableId, observable$, options);\n}\n\nvar SuspenseSubject = /*#__PURE__*/function (_Subject) {\n  _inheritsLoose(SuspenseSubject, _Subject);\n\n  function SuspenseSubject(innerObservable, _timeoutWindow) {\n    var _this;\n\n    _this = _Subject.call(this) || this;\n    _this._timeoutWindow = _timeoutWindow;\n    _this._hasValue = false;\n    _this._error = undefined;\n    _this._firstEmission = new Promise(function (resolve) {\n      return _this._resolveFirstEmission = resolve;\n    });\n    _this._innerObservable = innerObservable.pipe(tap(function (v) {\n      _this._next(v);\n    }, function (e) {\n      // save the error, so that we can raise on subscription or .value\n      // resolve the promise, so suspense tries again\n      _this._error = e;\n\n      _this._resolveFirstEmission();\n    }), catchError(function () {\n      return empty();\n    }), shareReplay(1)); // warm up the observable\n\n    _this._warmupSubscription = _this._innerObservable.subscribe(); // set a timeout for reseting the cache, subscriptions will cancel the timeout\n    // and reschedule again on unsubscribe\n\n    _this._timeoutHandler = setTimeout(_this._reset, _this._timeoutWindow);\n    return _this;\n  }\n\n  var _proto = SuspenseSubject.prototype;\n\n  _proto._next = function _next(value) {\n    this._hasValue = true;\n    this._value = value;\n\n    this._resolveFirstEmission();\n  };\n\n  _proto._reset = function _reset() {\n    var _this2 = this; // seems to be undefined in tests?\n\n\n    if (this._warmupSubscription) {\n      this._warmupSubscription.unsubscribe();\n    }\n\n    this._hasValue = false;\n    this._value = undefined;\n    this._error = undefined;\n    this._firstEmission = new Promise(function (resolve) {\n      return _this2._resolveFirstEmission = resolve;\n    });\n  };\n\n  _proto._subscribe = function _subscribe(subscriber) {\n    if (this._timeoutHandler) {\n      clearTimeout(this._timeoutHandler);\n    }\n\n    this._innerSubscriber = this._innerObservable.subscribe(subscriber);\n    return this._innerSubscriber.add(this._reset);\n  };\n\n  _createClass(SuspenseSubject, [{\n    key: \"hasValue\",\n    get: function get() {\n      // hasValue returns true if there's an error too\n      // so that after we resolve the promise & useObservable is called again\n      // we won't throw again\n      return this._hasValue || !!this._error;\n    }\n  }, {\n    key: \"value\",\n    get: function get() {\n      // TODO figure out how to reset the cache here, if I _reset() here before throwing\n      // it doesn't seem to work.\n      // As it is now, this will burn the cache entry until the timeout fires.\n      if (this._error) {\n        throw this._error;\n      }\n\n      return this._value;\n    }\n  }, {\n    key: \"firstEmission\",\n    get: function get() {\n      return this._firstEmission;\n    }\n  }, {\n    key: \"ourError\",\n    get: function get() {\n      return this._error;\n    }\n  }]);\n\n  return SuspenseSubject;\n}(Subject);\n\nvar DEFAULT_TIMEOUT = 30000; // Since we're side-effect free, we need to ensure our observable cache is global\n\nvar preloadedObservables = globalThis._reactFirePreloadedObservables || /*#__PURE__*/new Map();\n\nif (!globalThis._reactFirePreloadedObservables) {\n  globalThis._reactFirePreloadedObservables = preloadedObservables;\n} // Starts listening to an Observable.\n// Call this once you know you're going to render a\n// child that will consume the observable\n\n\nfunction preloadObservable(source, id) {\n  if (preloadedObservables.has(id)) {\n    return preloadedObservables.get(id);\n  } else {\n    var observable = new SuspenseSubject(source, DEFAULT_TIMEOUT);\n    preloadedObservables.set(id, observable);\n    return observable;\n  }\n}\n\nfunction useObservable(observableId, source, config) {\n  var _config;\n\n  if (config === void 0) {\n    config = {};\n  }\n\n  if (!observableId) {\n    throw new Error('cannot call useObservable without an observableId');\n  }\n\n  var observable = preloadObservable(source, observableId);\n  var hasInitialData = Object.keys(config).includes('initialData');\n  var suspenseEnabled = useSuspenseEnabledFromConfigAndContext(config.suspense);\n\n  if (!observable.hasValue && !((_config = config) == null ? void 0 : _config.initialData)) {\n    if (suspenseEnabled === true) {\n      throw observable.firstEmission;\n    }\n  }\n\n  var _React$useState = useState(function () {\n    return observable.hasValue ? observable.value : config.initialData;\n  }),\n      latest = _React$useState[0],\n      setValue = _React$useState[1];\n\n  useEffect(function () {\n    var subscription = observable.subscribe(function (v) {\n      setValue(function () {\n        return v;\n      });\n    }, function (e) {\n      throw e;\n    });\n    return function () {\n      return subscription.unsubscribe();\n    };\n  }, [observable]);\n  var status;\n\n  if (observable.hasError) {\n    status = 'error';\n  } else if (observable.hasValue || hasInitialData) {\n    status = 'success';\n  } else {\n    status = 'loading';\n  }\n\n  return {\n    status: status,\n    hasEmitted: observable.hasValue,\n    isComplete: observable.isStopped,\n    data: latest,\n    error: observable.ourError,\n    firstValuePromise: observable.firstEmission\n  };\n}\n\nvar cachedQueries$1 = globalThis._reactFireFirestoreQueryCache || [];\n\nif (!globalThis._reactFireFirestoreQueryCache) {\n  globalThis._reactFireFirestoreQueryCache = cachedQueries$1;\n}\n\nfunction getUniqueIdForFirestoreQuery(query) {\n  var index = cachedQueries$1.findIndex(function (cachedQuery) {\n    return cachedQuery.isEqual(query);\n  });\n\n  if (index > -1) {\n    return index;\n  }\n\n  return cachedQueries$1.push(query) - 1;\n} // starts a request for a firestore doc.\n// imports the firestore SDK automatically\n// if it hasn't been imported yet.\n//\n// there's a decent chance this gets called before the Firestore SDK\n// has been imported, so it takes a refProvider instead of a ref\n\n\nfunction preloadFirestoreDoc(refProvider, options) {\n  // TODO: Find an alternative that doesn't break the rules of hooks (conditional hook call)\n  var firebaseApp = (options == null ? void 0 : options.firebaseApp) || useFirebaseApp();\n  return preloadFirestore({\n    firebaseApp: firebaseApp\n  }).then(function (firestore) {\n    var ref = refProvider(firestore());\n    return preloadObservable(doc(ref), \"firestore:doc:\" + firebaseApp.name + \":\" + ref.path);\n  });\n}\n/**\r\n * Suscribe to Firestore Document changes\r\n *\r\n * @param ref - Reference to the document you want to listen to\r\n * @param options\r\n */\n\n\nfunction useFirestoreDoc(ref, options) {\n  var observableId = \"firestore:doc:\" + ref.firestore.app.name + \":\" + ref.path;\n  var observable$ = doc(ref);\n  return useObservable(observableId, observable$, options);\n}\n/**\r\n * Get a firestore document and don't subscribe to changes\r\n *\r\n * @param ref - Reference to the document you want to get\r\n * @param options\r\n */\n\n\nfunction useFirestoreDocOnce(ref, options) {\n  var observableId = \"firestore:docOnce:\" + ref.firestore.app.name + \":\" + ref.path;\n  var observable$ = doc(ref).pipe(first());\n  return useObservable(observableId, observable$, options);\n}\n/**\r\n * Suscribe to Firestore Document changes\r\n *\r\n * @param ref - Reference to the document you want to listen to\r\n * @param options\r\n */\n\n\nfunction useFirestoreDocData(ref, options) {\n  var idField = options ? checkIdField(options) : 'NO_ID_FIELD';\n  var observableId = \"firestore:docData:\" + ref.firestore.app.name + \":\" + ref.path + \":idField=\" + idField;\n  var observable = docData(ref, idField);\n  return useObservable(observableId, observable, options);\n}\n/**\r\n * Get a firestore document and don't subscribe to changes\r\n *\r\n * @param ref - Reference to the document you want to get\r\n * @param options\r\n */\n\n\nfunction useFirestoreDocDataOnce(ref, options) {\n  var idField = options ? checkIdField(options) : 'NO_ID_FIELD';\n  var observableId = \"firestore:docDataOnce:\" + ref.firestore.app.name + \":\" + ref.path + \":idField=\" + idField;\n  var observable$ = docData(ref, idField).pipe(first());\n  return useObservable(observableId, observable$, options);\n}\n/**\r\n * Subscribe to a Firestore collection\r\n *\r\n * @param ref - Reference to the collection you want to listen to\r\n * @param options\r\n */\n\n\nfunction useFirestoreCollection(query, options) {\n  var observableId = \"firestore:collection:\" + getUniqueIdForFirestoreQuery(query);\n  var observable$ = fromCollectionRef(query);\n  return useObservable(observableId, observable$, options);\n}\n/**\r\n * Subscribe to a Firestore collection and unwrap the snapshot.\r\n *\r\n * @param ref - Reference to the collection you want to listen to\r\n * @param options\r\n */\n\n\nfunction useFirestoreCollectionData(query, options) {\n  var idField = options ? checkIdField(options) : 'NO_ID_FIELD';\n  var observableId = \"firestore:collectionData:\" + getUniqueIdForFirestoreQuery(query) + \":idField=\" + idField;\n  var observable$ = collectionData(query, idField);\n  return useObservable(observableId, observable$, options);\n}\n\nfunction SuspenseWithPerf(_ref) {\n  var _performance;\n\n  var children = _ref.children,\n      traceId = _ref.traceId,\n      fallback = _ref.fallback,\n      firePerf = _ref.firePerf;\n\n  if (!firePerf) {\n    var firebaseApp = useFirebaseApp();\n    preloadPerformance({\n      firebaseApp: firebaseApp\n    }).then(function (perf) {\n      return perf();\n    });\n  }\n\n  var entries = ((_performance = performance) == null ? void 0 : _performance.getEntriesByName(traceId, 'measure')) || [];\n  var startMarkName = \"_\" + traceId + \"Start[\" + entries.length + \"]\";\n  var endMarkName = \"_\" + traceId + \"End[\" + entries.length + \"]\";\n\n  var Fallback = function Fallback() {\n    useLayoutEffect(function () {\n      var _performance2;\n\n      (_performance2 = performance) == null ? void 0 : _performance2.mark(startMarkName);\n      return function () {\n        var _performance3, _performance4;\n\n        (_performance3 = performance) == null ? void 0 : _performance3.mark(endMarkName);\n        (_performance4 = performance) == null ? void 0 : _performance4.measure(traceId, startMarkName, endMarkName);\n      };\n    }, []);\n    return createElement(Fragment, null, fallback);\n  };\n\n  return createElement(Suspense, {\n    fallback: createElement(Fallback, null)\n  }, children);\n}\n\nfunction parameter$(_ref) {\n  var remoteConfig = _ref.remoteConfig,\n      key = _ref.key,\n      getter = _ref.getter;\n  return new Observable(function (subscriber) {\n    remoteConfig.ensureInitialized().then(function () {\n      // 'this' for the getter loses context in the next()\n      // call, so it needs to be bound.\n      subscriber.next(getter.bind(remoteConfig)(key));\n    });\n  });\n}\n\nfunction getValue(remoteConfig, key) {\n  var getter = remoteConfig.getValue;\n  return parameter$({\n    remoteConfig: remoteConfig,\n    key: key,\n    getter: getter\n  });\n}\n\nfunction getString(remoteConfig, key) {\n  var getter = remoteConfig.getString;\n  return parameter$({\n    remoteConfig: remoteConfig,\n    key: key,\n    getter: getter\n  });\n}\n\nfunction getNumber(remoteConfig, key) {\n  var getter = remoteConfig.getNumber;\n  return parameter$({\n    remoteConfig: remoteConfig,\n    key: key,\n    getter: getter\n  });\n}\n\nfunction getBoolean(remoteConfig, key) {\n  var getter = remoteConfig.getBoolean;\n  return parameter$({\n    remoteConfig: remoteConfig,\n    key: key,\n    getter: getter\n  });\n}\n\nfunction getAll(remoteConfig) {\n  var getter = remoteConfig.getAll; // No key is needed for getAll()\n\n  return parameter$({\n    remoteConfig: remoteConfig,\n    key: '',\n    getter: getter\n  });\n}\n/**\r\n * Helper function to construct type safe functions. Since Remote Config has\r\n * methods that return different types for values, we need to be extra safe\r\n * to make sure we are not returning improper types by accident.\r\n * @param key\r\n * @param getter\r\n * @param remoteConfig\r\n */\n\n\nfunction useRemoteConfigValue_INTERNAL(key, getter, remoteConfig) {\n  var _remoteConfig$_storag; // TODO: Find an alternative that doesn't break the rules of hooks (conditional hook call)\n\n\n  remoteConfig = remoteConfig || useRemoteConfig(); // INVESTIGATE need to use a public API to get at the app name, one doesn't appear to exist...\n  // we might need to iterate over the Firebase apps and check for remoteConfig equality? this works for now\n\n  var appName = (_remoteConfig$_storag = remoteConfig._storage) == null ? void 0 : _remoteConfig$_storag.appName;\n  var $value = getter(remoteConfig, key);\n  var observableId = \"remoteConfig:\" + key + \":\" + getter.name + \":\" + appName;\n  return useObservable(observableId, $value);\n}\n/**\r\n * Accepts a key and optionally a Remote Config instance. Returns a\r\n * Remote Config Value.\r\n *\r\n * @param key The parameter key in Remote Config\r\n * @param remoteConfig Optional instance. If not provided ReactFire will either grab the default instance or lazy load.\r\n */\n\n\nfunction useRemoteConfigValue(key, remoteConfig) {\n  return useRemoteConfigValue_INTERNAL(key, getValue, remoteConfig);\n}\n/**\r\n * Convience method similar to useRemoteConfigValue. Returns a `string` from a Remote Config parameter.\r\n * @param key The parameter key in Remote Config\r\n * @param remoteConfig Optional instance. If not provided ReactFire will either grab the default instance or lazy load.\r\n */\n\n\nfunction useRemoteConfigString(key, remoteConfig) {\n  return useRemoteConfigValue_INTERNAL(key, getString, remoteConfig);\n}\n/**\r\n * Convience method similar to useRemoteConfigValue. Returns a `number` from a Remote Config parameter.\r\n * @param key The parameter key in Remote Config\r\n * @param remoteConfig Optional instance. If not provided ReactFire will either grab the default instance or lazy load.\r\n */\n\n\nfunction useRemoteConfigNumber(key, remoteConfig) {\n  return useRemoteConfigValue_INTERNAL(key, getNumber, remoteConfig);\n}\n/**\r\n * Convience method similar to useRemoteConfigValue. Returns a `boolean` from a Remote Config parameter.\r\n * @param key The parameter key in Remote Config\r\n * @param remoteConfig Optional instance. If not provided ReactFire will either grab the default instance or lazy load.\r\n */\n\n\nfunction useRemoteConfigBoolean(key, remoteConfig) {\n  return useRemoteConfigValue_INTERNAL(key, getBoolean, remoteConfig);\n}\n/**\r\n * Convience method similar to useRemoteConfigValue. Returns allRemote Config parameters.\r\n * @param key The parameter key in Remote Config\r\n * @param remoteConfig Optional instance. If not provided ReactFire will either grab the default instance or lazy load.\r\n */\n\n\nfunction useRemoteConfigAll(key, remoteConfig) {\n  return useRemoteConfigValue_INTERNAL(key, getAll, remoteConfig);\n}\n/**\r\n * modified version of rxFire's _fromTask\r\n *\r\n * @param task\r\n */\n\n\nfunction _fromTask(task) {\n  return new Observable(function (subscriber) {\n    var progress = function progress(snap) {\n      return subscriber.next(snap);\n    };\n\n    var error = function error(e) {\n      return subscriber.error(e);\n    };\n\n    var complete = function complete() {\n      return subscriber.complete();\n    };\n\n    task.on('state_changed', progress, error, complete); // I REMOVED THE UNSUBSCRIBE RETURN BECAUSE IT CANCELS THE UPLOAD\n    // https://github.com/firebase/firebase-js-sdk/issues/1659\n  });\n}\n/**\r\n * Subscribe to the progress of a storage task\r\n *\r\n * @param task - the task you want to listen to\r\n * @param ref - reference to the blob the task is acting on\r\n * @param options\r\n */\n\n\nfunction useStorageTask(task, ref, options) {\n  var observableId = \"storage:task:\" + ref.toString();\n\n  var observable$ = _fromTask(task);\n\n  return useObservable(observableId, observable$, options ? options.initialData : undefined);\n}\n/**\r\n * Subscribe to a storage ref's download URL\r\n *\r\n * @param ref - reference to the blob you want to download\r\n * @param options\r\n */\n\n\nfunction useStorageDownloadURL(ref, options) {\n  var observableId = \"storage:downloadUrl:\" + ref.toString();\n  var observable$ = getDownloadURL(ref);\n  return useObservable(observableId, observable$, options);\n}\n\nfunction StorageFromContext(props) {\n  var storage = useStorage();\n  props = _extends({}, props, {\n    storage: storage\n  });\n  return createElement(INTERNALStorageImage, Object.assign({}, props));\n}\n\nfunction INTERNALStorageImage(props) {\n  var storage = props.storage,\n      storagePath = props.storagePath,\n      suspense = props.suspense,\n      placeHolder = props.placeHolder,\n      imgProps = _objectWithoutPropertiesLoose(props, [\"storage\", \"storagePath\", \"suspense\", \"placeHolder\"]);\n\n  var reactfireOptions = {\n    suspense: useSuspenseEnabledFromConfigAndContext(suspense)\n  };\n\n  if (!storage) {\n    throw new Error('Storage was not passed to component INTERNALStorageImage. This should not be possible');\n  }\n\n  var _useStorageDownloadUR = useStorageDownloadURL(storage.ref(storagePath), reactfireOptions),\n      status = _useStorageDownloadUR.status,\n      imgSrc = _useStorageDownloadUR.data;\n\n  if (status === 'success') {\n    if (!(imgProps.alt || imgProps.alt === '')) {\n      console.warn(\"No alt prop provided for StorageImage with storagePath \\\"\" + storagePath + \"\\\"\", 'img elements must have an alt prop, either with meaningful text, or an empty string for decorative images');\n    }\n\n    return createElement(\"img\", Object.assign({\n      src: imgSrc,\n      alt: imgProps.alt\n    }, imgProps));\n  } else {\n    return placeHolder != null ? placeHolder : createElement(Fragment, null, \"''\");\n  }\n}\n\nfunction StorageImage(props) {\n  var storage = props.storage;\n\n  if (storage) {\n    return createElement(INTERNALStorageImage, Object.assign({}, props));\n  } else {\n    return createElement(StorageFromContext, Object.assign({}, props));\n  }\n}\n\nfunction checkOptions(options, field) {\n  // make sure the field passed in is a valid key of ReactFire Options\n  if (field === 'idField' || field === 'initialData' || field === 'suspense') {\n    return options ? options[field] : undefined;\n  }\n\n  throw new Error(\"Field \\\"\" + field + \"\\\" is not a valid key in ReactFireOptions\");\n}\n\nfunction checkinitialData(options) {\n  return checkOptions(options, 'initialData');\n}\n\nfunction checkIdField(options) {\n  return checkOptions(options, 'idField');\n}\n\nexport { AuthCheck, ClaimsCheck, FirebaseAppProvider, StorageImage, SuspenseWithPerf, analytics, auth, checkIdField, checkOptions, checkinitialData, database, firestore, functions, messaging, performance$1 as performance, preloadAnalytics, preloadAuth, preloadDatabase, preloadFirestore, preloadFirestoreDoc, preloadFunctions, preloadMessaging, preloadObservable, preloadPerformance, preloadRemoteConfig, preloadStorage, preloadUser, remoteConfig, storage, useAnalytics, useAuth, useDatabase, useDatabaseList, useDatabaseListData, useDatabaseObject, useDatabaseObjectData, useFirebaseApp, useFirestore, useFirestoreCollection, useFirestoreCollectionData, useFirestoreDoc, useFirestoreDocData, useFirestoreDocDataOnce, useFirestoreDocOnce, useFunctions, useIdTokenResult, useIsSuspenseEnabled, useMessaging, useObservable, usePerformance, useRemoteConfig, useRemoteConfigAll, useRemoteConfigBoolean, useRemoteConfigNumber, useRemoteConfigString, useRemoteConfigValue, useStorage, useStorageDownloadURL, useStorageTask, useSuspenseEnabledFromConfigAndContext, useUser, version };","map":{"version":3,"sources":["../src/sdk.tsx","../src/firebaseApp.tsx","../src/auth.tsx","../src/database.tsx","../src/SuspenseSubject.ts","../src/useObservable.ts","../src/firestore.tsx","../src/performance.tsx","../src/remote-config/getValue.tsx","../src/remote-config/index.tsx","../src/storage.tsx","../src/index.ts"],"names":["useComponent","contextualApp","useFirebaseApp","suspenseEnabled","useSuspenseEnabledFromConfigAndContext","sdkSubject","preload","app","firebase","componentName","get","target","apply","component","args","useAuth","proxyComponent","useAnalytics","useDatabase","useFirestore","useFunctions","useMessaging","usePerformance","useRemoteConfig","useStorage","auth","analytics","database","firestore","functions","messaging","performance","remoteConfig","storage","options","settingsCallback","preloadObservable","importSDK","instanceFactory","Promise","emitter","preloadAuth","preloadFactory","preloadAnalytics","preloadDatabase","preloadFirestore","preloadFunctions","preloadMessaging","preloadPerformance","preloadRemoteConfig","preloadStorage","DEFAULT_APP_NAME","FirebaseAppContext","React","SuspenseEnabledContext","version","shallowEq","a","Object","b","FirebaseAppProvider","props","firebaseConfig","appName","suspense","firebaseApp","existingApp","reactVersion","value","useIsSuspenseEnabled","suspenseFromConfig","suspenseFromContext","preloadUser","result","user","useUser","observableId","observable$","currentUser","useObservable","initialData","useIdTokenResult","forceRefresh","from","ClaimsCheck","fallback","children","requiredClaims","data","claims","missingClaims","expected","actual","AuthCheck","cachedQueries","globalThis","index","cachedQuery","useDatabaseObject","ref","object","map","changeToData","val","change","keyField","useDatabaseObjectData","idField","checkIdField","objectVal","useDatabaseList","hash","getUniqueIdForDatabaseQuery","list","useDatabaseListData","listVal","SuspenseSubject","tap","catchError","empty","shareReplay","setTimeout","_next","_reset","_subscribe","clearTimeout","DEFAULT_TIMEOUT","preloadedObservables","source","id","observable","config","hasInitialData","latest","setValue","subscription","status","hasEmitted","isComplete","error","firstValuePromise","firstEmission","preloadFirestoreDoc","refProvider","doc","useFirestoreDoc","useFirestoreDocOnce","first","useFirestoreDocData","docData","useFirestoreDocDataOnce","useFirestoreCollection","query","getUniqueIdForFirestoreQuery","fromCollectionRef","useFirestoreCollectionData","collectionData","SuspenseWithPerf","traceId","firePerf","perf","entries","startMarkName","endMarkName","Fallback","key","getter","subscriber","getValue","parameter$","getString","getNumber","getBoolean","getAll","$value","useRemoteConfigValue","useRemoteConfigValue_INTERNAL","useRemoteConfigString","useRemoteConfigNumber","useRemoteConfigBoolean","useRemoteConfigAll","progress","complete","task","useStorageTask","_fromTask","useStorageDownloadURL","getDownloadURL","storagePath","placeHolder","imgProps","reactfireOptions","imgSrc","console","src","alt","StorageImage","checkOptions","field","checkinitialData"],"mappings":"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","sourcesContent":["import { useFirebaseApp, useSuspenseEnabledFromConfigAndContext, preloadObservable } from './';\nimport firebase from 'firebase/app';\nimport { Observable } from 'rxjs';\n\ntype ComponentName = 'analytics' | 'auth' | 'database' | 'firestore' | 'functions' | 'messaging' | 'performance' | 'remoteConfig' | 'storage';\n\ntype ValueOf<T> = T[keyof T];\ntype App = firebase.app.App;\ntype FirebaseInstanceFactory = ValueOf<Pick<App, ComponentName>>;\ntype FirebaseNamespaceComponent = ValueOf<Pick<typeof firebase, ComponentName>>;\n\nfunction importSDK(sdk: ComponentName) {\n  switch (sdk) {\n    case 'analytics':\n      return import(/* webpackChunkName: \"analytics\" */ 'firebase/analytics');\n    case 'auth':\n      return import(/* webpackChunkName: \"auth\" */ 'firebase/auth');\n    case 'database':\n      return import(/* webpackChunkName: \"database\" */ 'firebase/database');\n    case 'firestore':\n      return import(/* webpackChunkName: \"firestore\" */ 'firebase/firestore');\n    case 'functions':\n      return import(/* webpackChunkName: \"functions\" */ 'firebase/functions');\n    case 'messaging':\n      return import(/* webpackChunkName: \"messaging\" */ 'firebase/messaging');\n    case 'performance':\n      return import(/* webpackChunkName: \"performance\" */ 'firebase/performance');\n    case 'remoteConfig':\n      return import(/* webpackChunkName: \"remoteConfig\" */ 'firebase/remote-config');\n    case 'storage':\n      return import(/* webpackChunkName: \"storage\" */ 'firebase/storage');\n  }\n}\n\nfunction proxyComponent(componentName: 'auth'): typeof firebase.auth;\nfunction proxyComponent(componentName: 'analytics'): typeof firebase.analytics;\nfunction proxyComponent(componentName: 'database'): typeof firebase.database;\nfunction proxyComponent(componentName: 'firestore'): typeof firebase.firestore;\nfunction proxyComponent(componentName: 'functions'): typeof firebase.functions;\nfunction proxyComponent(componentName: 'messaging'): typeof firebase.messaging;\nfunction proxyComponent(componentName: 'performance'): typeof firebase.performance;\nfunction proxyComponent(componentName: 'remoteConfig'): typeof firebase.remoteConfig;\nfunction proxyComponent(componentName: 'storage'): typeof firebase.storage;\nfunction proxyComponent(componentName: ComponentName): FirebaseNamespaceComponent {\n  let contextualApp: App | undefined;\n  const useComponent = (app?: App, suspense?: boolean) => {\n    contextualApp = useFirebaseApp();\n    const suspenseEnabled = useSuspenseEnabledFromConfigAndContext(suspense);\n\n    const sdkSubject = preload(componentName, app || contextualApp);\n\n    if (!sdkSubject.hasValue && suspenseEnabled) {\n      throw sdkSubject.firstEmission;\n    } else if (!sdkSubject.hasValue && !suspenseEnabled && !firebase[componentName]) {\n      throw new Error(\n        `ReactFire: \"firebase/${componentName}\" not found. Please import it in your component, or call preload${componentName.charAt(0).toUpperCase() +\n          componentName.slice(1)} and wait for it to resolve. ReactFire can only auto-import Firebase libraries if Suspense mode is enabled.`\n      );\n    }\n\n    // get value to throw if there's an error\n    sdkSubject.value; // eslint-disable-line @typescript-eslint/no-unused-expressions\n    return firebase[componentName];\n  };\n  return new Proxy(useComponent, {\n    // @ts-ignore: TODO: Fix the types here\n    get: (target, p) => target()[p],\n    apply: (target, _this, args) => {\n      const component = target(args[0]).bind(_this);\n      // If they don't pass an app, assume the app in context rather than [DEFAULT]\n      if (!args[0]) {\n        args[0] = contextualApp;\n      }\n      return component(...args);\n    }\n  }) as any;\n}\n\nexport const useAuth = proxyComponent('auth');\nexport const useAnalytics = proxyComponent('analytics');\nexport const useDatabase = proxyComponent('database');\nexport const useFirestore = proxyComponent('firestore');\nexport const useFunctions = proxyComponent('functions');\nexport const useMessaging = proxyComponent('messaging');\nexport const usePerformance = proxyComponent('performance');\nexport const useRemoteConfig = proxyComponent('remoteConfig');\nexport const useStorage = proxyComponent('storage');\n\nexport const auth = useAuth;\nexport const analytics = useAnalytics;\nexport const database = useDatabase;\nexport const firestore = useFirestore;\nexport const functions = useFunctions;\nexport const messaging = useMessaging;\nexport const performance = usePerformance;\nexport const remoteConfig = useRemoteConfig;\nexport const storage = useStorage;\n\nexport type PreloadOptions<T> = {\n  firebaseApp: App;\n  setup?: (instanceFactory: T) => void | Promise<any>;\n  suspense?: boolean;\n};\n\nfunction preloadFactory(componentName: 'auth'): (options: PreloadOptions<App['auth']>) => Promise<App['auth']>;\nfunction preloadFactory(componentName: 'analytics'): (options: PreloadOptions<App['analytics']>) => Promise<App['analytics']>;\nfunction preloadFactory(componentName: 'database'): (options: PreloadOptions<App['database']>) => Promise<App['database']>;\nfunction preloadFactory(componentName: 'firestore'): (options: PreloadOptions<App['firestore']>) => Promise<App['firestore']>;\nfunction preloadFactory(componentName: 'functions'): (options: PreloadOptions<App['functions']>) => Promise<App['functions']>;\nfunction preloadFactory(componentName: 'messaging'): (options: PreloadOptions<App['messaging']>) => Promise<App['messaging']>;\nfunction preloadFactory(componentName: 'performance'): (options: PreloadOptions<App['performance']>) => Promise<App['performance']>;\nfunction preloadFactory(componentName: 'remoteConfig'): (options: PreloadOptions<App['remoteConfig']>) => Promise<App['remoteConfig']>;\nfunction preloadFactory(componentName: 'storage'): (options: PreloadOptions<App['storage']>) => Promise<App['storage']>;\nfunction preloadFactory(componentName: ComponentName) {\n  return (options: PreloadOptions<FirebaseInstanceFactory>) => preload(componentName, options.firebaseApp, options.setup).toPromise();\n}\n\nfunction preload(componentName: ComponentName, firebaseApp: App, settingsCallback: (instanceFactory: FirebaseInstanceFactory) => any = () => {}) {\n  const app = firebaseApp;\n\n  return preloadObservable(\n    new Observable(emitter => {\n      importSDK(componentName)\n        .then(() => {\n          const instanceFactory: FirebaseInstanceFactory = app[componentName].bind(app);\n          Promise.resolve(settingsCallback(instanceFactory)).then(() => {\n            emitter.next(instanceFactory);\n            emitter.complete();\n          });\n        })\n        .catch(e => {\n          emitter.error(e);\n          emitter.complete();\n        });\n    }),\n    `firebase-sdk:${componentName}:${app.name}`\n  );\n}\n\nexport const preloadAuth = preloadFactory('auth');\nexport const preloadAnalytics = preloadFactory('analytics');\nexport const preloadDatabase = preloadFactory('database');\nexport const preloadFirestore = preloadFactory('firestore');\nexport const preloadFunctions = preloadFactory('functions');\nexport const preloadMessaging = preloadFactory('messaging');\nexport const preloadPerformance = preloadFactory('performance');\nexport const preloadRemoteConfig = preloadFactory('remoteConfig');\nexport const preloadStorage = preloadFactory('storage');\n","import firebase from 'firebase/app';\nimport * as React from 'react';\n\nexport * from './sdk';\n\ntype FirebaseAppContextValue = firebase.app.App;\n\n// INVESTIGATE I don't like magic strings, can we have export this in js-sdk?\nconst DEFAULT_APP_NAME = '[DEFAULT]';\n\nconst FirebaseAppContext = React.createContext<FirebaseAppContextValue | undefined>(undefined);\n\nconst SuspenseEnabledContext = React.createContext<boolean>(false);\n\ntype Props = {\n  firebaseApp?: firebase.app.App;\n  firebaseConfig?: Object;\n  appName?: string;\n  suspense?: boolean;\n};\n\n// @ts-ignore: \"__REACTFIRE_VERSION__\" is replaced with actual ReactFire version (see babel.config.js)\nexport const version = __REACTFIRE_VERSION__;\n\nconst shallowEq = (a: { [key: string]: any }, b: { [key: string]: any }) => a === b || [...Object.keys(a), ...Object.keys(b)].every(key => a[key] === b[key]);\n\nexport function FirebaseAppProvider(props: Props & { [key: string]: unknown }) {\n  const { firebaseConfig, appName, suspense } = props;\n\n  const firebaseApp: firebase.app.App = React.useMemo(() => {\n    if (props.firebaseApp) {\n      return props.firebaseApp;\n    }\n\n    const existingApp = firebase.apps.find(app => app.name === (appName || DEFAULT_APP_NAME));\n    if (existingApp) {\n      if (firebaseConfig && shallowEq(existingApp.options, firebaseConfig)) {\n        return existingApp;\n      } else {\n        throw new Error(\n          `Does not match the options already provided to the ${appName || 'default'} firebase app instance, give this new instance a different appName.`\n        );\n      }\n    } else {\n      if (!firebaseConfig) {\n        throw new Error('No firebaseConfig provided');\n      }\n\n      // TODO: DOUBLE CHECK THAT THIS GETS CALLED\n      const reactVersion = React.version || 'unknown';\n      firebase.registerVersion('react', reactVersion);\n      firebase.registerVersion('reactfire', version);\n      return firebase.initializeApp(firebaseConfig, appName);\n    }\n  }, [props.firebaseApp, firebaseConfig, appName]);\n\n  return (\n    <FirebaseAppContext.Provider value={firebaseApp}>\n      <SuspenseEnabledContext.Provider value={suspense ?? false} {...props} />\n    </FirebaseAppContext.Provider>\n  );\n}\n\nexport function useIsSuspenseEnabled(): boolean {\n  const suspense = React.useContext(SuspenseEnabledContext);\n\n  // default to false if not available in context\n  return suspense ?? false;\n}\n\nexport function useSuspenseEnabledFromConfigAndContext(suspenseFromConfig?: boolean): boolean {\n  let suspenseFromContext = React.useContext(SuspenseEnabledContext);\n\n  // prioritize config over context\n  if (suspenseFromConfig !== undefined) {\n    return suspenseFromConfig;\n  }\n\n  return suspenseFromContext;\n}\n\nexport function useFirebaseApp() {\n  const firebaseApp = React.useContext(FirebaseAppContext);\n  if (!firebaseApp) {\n    throw new Error('Cannot call useFirebaseApp unless your component is within a FirebaseAppProvider');\n  }\n\n  return firebaseApp;\n}\n","import firebase from 'firebase/app';\nimport * as React from 'react';\nimport { user } from 'rxfire/auth';\nimport { preloadAuth, preloadObservable, ReactFireOptions, useAuth, useObservable, ObservableStatus } from './';\nimport { from } from 'rxjs';\nimport { useFirebaseApp } from './firebaseApp';\n\nexport function preloadUser(options?: { firebaseApp?: firebase.app.App }) {\n  // TODO: Find an alternative that doesn't break the rules of hooks (conditional hook call)\n  const firebaseApp = options?.firebaseApp || useFirebaseApp();\n\n  return preloadAuth({ firebaseApp }).then(auth => {\n    const result = preloadObservable(user(auth()), `auth:user:${firebaseApp.name}`);\n    return result.toPromise();\n  });\n}\n\n/**\n * Subscribe to Firebase auth state changes, including token refresh\n *\n * @param auth - the [firebase.auth](https://firebase.google.com/docs/reference/js/firebase.auth) object\n * @param options\n */\nexport function useUser<T = unknown>(auth?: firebase.auth.Auth, options?: ReactFireOptions<T>): ObservableStatus<firebase.User> {\n  // TODO: Find an alternative that doesn't break the rules of hooks (conditional hook call)\n  auth = auth || useAuth();\n\n  if (!auth) {\n    throw new Error('firebase.auth not found');\n  }\n\n  const observableId = `auth:user:${auth.app.name}`;\n  const observable$ = user(auth);\n\n  let currentUser = auth.currentUser;\n\n  // If currentUser is available, skip initialData\n  if (options?.initialData && !currentUser) {\n    currentUser = options.initialData;\n  }\n\n  return useObservable(observableId, observable$, { ...options, initialData: currentUser });\n}\n\nexport function useIdTokenResult(\n  user: firebase.User,\n  forceRefresh: boolean = false,\n  options?: ReactFireOptions<firebase.auth.IdTokenResult>\n): ObservableStatus<firebase.auth.IdTokenResult> {\n  if (!user) {\n    throw new Error('you must provide a user');\n  }\n\n  const observableId = `auth:idTokenResult:${user.uid}:forceRefresh=${forceRefresh}`;\n  const observable$ = from(user.getIdTokenResult(forceRefresh));\n\n  return useObservable(observableId, observable$, options);\n}\n\nexport interface AuthCheckProps {\n  auth?: firebase.auth.Auth;\n  fallback: React.ReactNode;\n  children: React.ReactNode;\n  requiredClaims?: Object;\n}\n\nexport interface ClaimsCheckProps {\n  user: firebase.User;\n  fallback: React.ReactNode;\n  children: React.ReactNode;\n  requiredClaims?: { [key: string]: any };\n}\n\nexport function ClaimsCheck({ user, fallback, children, requiredClaims }: ClaimsCheckProps) {\n  const { data } = useIdTokenResult(user, false);\n  const { claims } = data;\n  const missingClaims: { [key: string]: { expected: string; actual: string } } = {};\n\n  if (requiredClaims) {\n    Object.keys(requiredClaims).forEach(claim => {\n      if (requiredClaims[claim] !== claims[claim]) {\n        missingClaims[claim] = {\n          expected: requiredClaims[claim],\n          actual: claims[claim]\n        };\n      }\n    });\n  }\n\n  if (Object.keys(missingClaims).length === 0) {\n    return <>{children}</>;\n  } else {\n    return <>{fallback}</>;\n  }\n}\n\nexport function AuthCheck({ auth, fallback, children, requiredClaims }: AuthCheckProps): JSX.Element {\n  const { data: user } = useUser<firebase.User>(auth);\n\n  if (user) {\n    return requiredClaims ? (\n      <ClaimsCheck user={user} fallback={fallback} requiredClaims={requiredClaims}>\n        {children}\n      </ClaimsCheck>\n    ) : (\n      <>{children}</>\n    );\n  } else {\n    return <>{fallback}</>;\n  }\n}\n","import firebase from 'firebase/app';\nimport { list, object, QueryChange, listVal } from 'rxfire/database';\nimport { ReactFireOptions, useObservable, checkIdField, ObservableStatus, ReactFireGlobals } from './';\n\nimport { Observable } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\n// Since we're side-effect free, we need to ensure our observableId cache is global\nconst cachedQueries: Array<firebase.database.Query> = ((globalThis as any) as ReactFireGlobals)._reactFireDatabaseCachedQueries || [];\n\nif (!((globalThis as any) as ReactFireGlobals)._reactFireDatabaseCachedQueries) {\n  ((globalThis as any) as ReactFireGlobals)._reactFireDatabaseCachedQueries = cachedQueries;\n}\n\nfunction getUniqueIdForDatabaseQuery(query: firebase.database.Query) {\n  const index = cachedQueries.findIndex(cachedQuery => cachedQuery.isEqual(query));\n  if (index > -1) {\n    return index;\n  }\n  return cachedQueries.push(query) - 1;\n}\n\n/**\n * Subscribe to a Realtime Database object\n *\n * @param ref - Reference to the DB object you want to listen to\n * @param options\n */\nexport function useDatabaseObject<T = unknown>(ref: firebase.database.Reference, options?: ReactFireOptions<T>): ObservableStatus<QueryChange | T> {\n  const observableId = `database:object:${ref.toString()}`;\n  const observable$ = object(ref);\n\n  return useObservable(observableId, observable$, options);\n}\n\n// ============================================================================\n// TODO: switch to rxfire's objectVal once this PR is merged:\n// https://github.com/firebase/firebase-js-sdk/pull/2352\n\nfunction objectVal<T>(query: firebase.database.Query, keyField?: string): Observable<T> {\n  return object(query).pipe(map(change => changeToData(change, keyField) as T));\n}\n\nfunction changeToData(change: QueryChange, keyField?: string): {} {\n  const val = change.snapshot.val();\n\n  // don't worry about setting IDs if the value is a primitive type\n  if (typeof val !== 'object') {\n    return val;\n  }\n\n  return {\n    ...change.snapshot.val(),\n    ...(keyField ? { [keyField]: change.snapshot.key } : null)\n  };\n}\n// ============================================================================\n\nexport function useDatabaseObjectData<T>(ref: firebase.database.Reference, options?: ReactFireOptions<T>): ObservableStatus<T> {\n  const idField = options ? checkIdField(options) : 'NO_ID_FIELD';\n  const observableId = `database:objectVal:${ref.toString()}:idField=${idField}`;\n  const observable$ = objectVal(ref, idField);\n\n  return useObservable(observableId, observable$, options);\n}\n\n/**\n * Subscribe to a Realtime Database list\n *\n * @param ref - Reference to the DB List you want to listen to\n * @param options\n */\nexport function useDatabaseList<T = { [key: string]: unknown }>(\n  ref: firebase.database.Reference | firebase.database.Query,\n  options?: ReactFireOptions<T[]>\n): ObservableStatus<QueryChange[] | T[]> {\n  const hash = `database:list:${getUniqueIdForDatabaseQuery(ref)}`;\n  const observable$ = list(ref);\n\n  return useObservable(hash, observable$, options);\n}\n\nexport function useDatabaseListData<T = { [key: string]: unknown }>(\n  ref: firebase.database.Reference | firebase.database.Query,\n  options?: ReactFireOptions<T[]>\n): ObservableStatus<T[]> {\n  const idField = options ? checkIdField(options) : 'NO_ID_FIELD';\n  const observableId = `database:listVal:${getUniqueIdForDatabaseQuery(ref)}:idField=${idField}`;\n  const observable$ = listVal(ref, idField);\n  return useObservable(observableId, observable$, options);\n}\n","import { empty, Observable, Subject, Subscriber, Subscription } from 'rxjs';\nimport { catchError, shareReplay, tap } from 'rxjs/operators';\n\nexport class SuspenseSubject<T> extends Subject<T> {\n  private _value: T | undefined;\n  private _hasValue = false;\n  private _timeoutHandler: NodeJS.Timeout;\n  private _firstEmission: Promise<void>;\n  private _error: any = undefined;\n  private _innerObservable: Observable<T>;\n  private _warmupSubscription: Subscription;\n\n  // @ts-ignore: TODO: double check to see if this is an RXJS thing or if we should listen to TS\n  private _innerSubscriber: Subscription;\n  // @ts-ignore: TODO: double check to see if this is an RXJS thing or if we should listen to TS\n  private _resolveFirstEmission: () => void;\n\n  constructor(innerObservable: Observable<T>, private _timeoutWindow: number) {\n    super();\n    this._firstEmission = new Promise<void>(resolve => (this._resolveFirstEmission = resolve));\n    this._innerObservable = innerObservable.pipe(\n      tap(\n        v => {\n          this._next(v);\n        },\n        e => {\n          // save the error, so that we can raise on subscription or .value\n          // resolve the promise, so suspense tries again\n          this._error = e;\n          this._resolveFirstEmission();\n        }\n      ),\n      catchError(() => empty()),\n      shareReplay(1)\n    );\n    // warm up the observable\n    this._warmupSubscription = this._innerObservable.subscribe();\n\n    // set a timeout for reseting the cache, subscriptions will cancel the timeout\n    // and reschedule again on unsubscribe\n    this._timeoutHandler = setTimeout(this._reset, this._timeoutWindow);\n  }\n\n  get hasValue(): boolean {\n    // hasValue returns true if there's an error too\n    // so that after we resolve the promise & useObservable is called again\n    // we won't throw again\n    return this._hasValue || !!this._error;\n  }\n\n  get value(): T | undefined {\n    // TODO figure out how to reset the cache here, if I _reset() here before throwing\n    // it doesn't seem to work.\n    // As it is now, this will burn the cache entry until the timeout fires.\n    if (this._error) {\n      throw this._error;\n    }\n    return this._value;\n  }\n\n  get firstEmission(): Promise<void> {\n    return this._firstEmission;\n  }\n\n  private _next(value: T) {\n    this._hasValue = true;\n    this._value = value;\n    this._resolveFirstEmission();\n  }\n\n  private _reset() {\n    // seems to be undefined in tests?\n    if (this._warmupSubscription) {\n      this._warmupSubscription.unsubscribe();\n    }\n    this._hasValue = false;\n    this._value = undefined;\n    this._error = undefined;\n    this._firstEmission = new Promise<void>(resolve => (this._resolveFirstEmission = resolve));\n  }\n\n  _subscribe(subscriber: Subscriber<T>): Subscription {\n    if (this._timeoutHandler) {\n      clearTimeout(this._timeoutHandler);\n    }\n    this._innerSubscriber = this._innerObservable.subscribe(subscriber);\n    return this._innerSubscriber.add(this._reset);\n  }\n\n  get ourError() {\n    return this._error;\n  }\n}\n","import * as React from 'react';\nimport { Observable } from 'rxjs';\nimport { SuspenseSubject } from './SuspenseSubject';\nimport { useSuspenseEnabledFromConfigAndContext } from './firebaseApp';\nimport { ReactFireGlobals, ReactFireOptions } from './';\n\nconst DEFAULT_TIMEOUT = 30_000;\n\n// Since we're side-effect free, we need to ensure our observable cache is global\nconst preloadedObservables: Map<string, SuspenseSubject<any>> = ((globalThis as any) as ReactFireGlobals)._reactFirePreloadedObservables || new Map();\n\nif (!((globalThis as any) as ReactFireGlobals)._reactFirePreloadedObservables) {\n  ((globalThis as any) as ReactFireGlobals)._reactFirePreloadedObservables = preloadedObservables;\n}\n\n// Starts listening to an Observable.\n// Call this once you know you're going to render a\n// child that will consume the observable\nexport function preloadObservable<T>(source: Observable<T>, id: string) {\n  if (preloadedObservables.has(id)) {\n    return preloadedObservables.get(id) as SuspenseSubject<T>;\n  } else {\n    const observable = new SuspenseSubject(source, DEFAULT_TIMEOUT);\n    preloadedObservables.set(id, observable);\n    return observable;\n  }\n}\n\nexport interface ObservableStatus<T> {\n  status:\n    | 'loading' // waiting for first value from observable\n    | 'error'\n    | 'success'; // has received at least one value\n  hasEmitted: boolean; // has received at least one value\n  isComplete: boolean; // observable has triggered onComplete event\n  data: T; // latest data from observable\n  error: Error | undefined;\n  firstValuePromise: Promise<void>; // promise that resolves after first emit from observable\n}\n\nexport function useObservable<T>(observableId: string, source: Observable<T | any>, config: ReactFireOptions = {}): ObservableStatus<T> {\n  if (!observableId) {\n    throw new Error('cannot call useObservable without an observableId');\n  }\n  const observable = preloadObservable(source, observableId);\n\n  const hasInitialData = Object.keys(config).includes('initialData');\n\n  const suspenseEnabled = useSuspenseEnabledFromConfigAndContext(config.suspense);\n\n  if (!observable.hasValue && !config?.initialData) {\n    if (suspenseEnabled === true) {\n      throw observable.firstEmission;\n    }\n  }\n\n  const [latest, setValue] = React.useState(() => (observable.hasValue ? observable.value : config.initialData));\n  React.useEffect(() => {\n    const subscription = observable.subscribe(\n      v => {\n        setValue(() => v);\n      },\n      e => {\n        throw e;\n      }\n    );\n    return () => subscription.unsubscribe();\n  }, [observable]);\n\n  let status: ObservableStatus<T>['status'];\n\n  if (observable.hasError) {\n    status = 'error';\n  } else if (observable.hasValue || hasInitialData) {\n    status = 'success';\n  } else {\n    status = 'loading';\n  }\n\n  return {\n    status,\n    hasEmitted: observable.hasValue,\n    isComplete: observable.isStopped,\n    data: latest,\n    error: observable.ourError,\n    firstValuePromise: observable.firstEmission\n  };\n}\n","import firebase from 'firebase/app';\nimport { collectionData, doc, docData, fromCollectionRef } from 'rxfire/firestore';\nimport { preloadFirestore, ReactFireOptions, useObservable, checkIdField, ReactFireGlobals } from './';\nimport { preloadObservable, ObservableStatus } from './useObservable';\nimport { first } from 'rxjs/operators';\nimport { useFirebaseApp } from './firebaseApp';\n\n// Since we're side-effect free, we need to ensure our observableId cache is global\nconst cachedQueries: Array<firebase.firestore.Query> = ((globalThis as any) as ReactFireGlobals)._reactFireFirestoreQueryCache || [];\n\nif (!((globalThis as any) as ReactFireGlobals)._reactFireFirestoreQueryCache) {\n  ((globalThis as any) as ReactFireGlobals)._reactFireFirestoreQueryCache = cachedQueries;\n}\n\nfunction getUniqueIdForFirestoreQuery(query: firebase.firestore.Query) {\n  const index = cachedQueries.findIndex(cachedQuery => cachedQuery.isEqual(query));\n  if (index > -1) {\n    return index;\n  }\n  return cachedQueries.push(query) - 1;\n}\n\n// starts a request for a firestore doc.\n// imports the firestore SDK automatically\n// if it hasn't been imported yet.\n//\n// there's a decent chance this gets called before the Firestore SDK\n// has been imported, so it takes a refProvider instead of a ref\nexport function preloadFirestoreDoc(\n  refProvider: (firestore: firebase.firestore.Firestore) => firebase.firestore.DocumentReference,\n  options?: { firebaseApp?: firebase.app.App }\n) {\n  // TODO: Find an alternative that doesn't break the rules of hooks (conditional hook call)\n  const firebaseApp = options?.firebaseApp || useFirebaseApp();\n\n  return preloadFirestore({ firebaseApp }).then(firestore => {\n    const ref = refProvider(firestore());\n    return preloadObservable(doc(ref), `firestore:doc:${firebaseApp.name}:${ref.path}`);\n  });\n}\n\n/**\n * Suscribe to Firestore Document changes\n *\n * @param ref - Reference to the document you want to listen to\n * @param options\n */\nexport function useFirestoreDoc<T = unknown>(\n  ref: firebase.firestore.DocumentReference,\n  options?: ReactFireOptions<T>\n): ObservableStatus<T extends {} ? T : firebase.firestore.DocumentSnapshot> {\n  const observableId = `firestore:doc:${ref.firestore.app.name}:${ref.path}`;\n  const observable$ = doc(ref);\n\n  return useObservable(observableId, observable$, options);\n}\n\n/**\n * Get a firestore document and don't subscribe to changes\n *\n * @param ref - Reference to the document you want to get\n * @param options\n */\nexport function useFirestoreDocOnce<T = unknown>(\n  ref: firebase.firestore.DocumentReference,\n  options?: ReactFireOptions<T>\n): ObservableStatus<T extends {} ? T : firebase.firestore.DocumentSnapshot> {\n  const observableId = `firestore:docOnce:${ref.firestore.app.name}:${ref.path}`;\n  const observable$ = doc(ref).pipe(first());\n\n  return useObservable(observableId, observable$, options);\n}\n\n/**\n * Suscribe to Firestore Document changes\n *\n * @param ref - Reference to the document you want to listen to\n * @param options\n */\nexport function useFirestoreDocData<T>(ref: firebase.firestore.DocumentReference, options?: ReactFireOptions<T>): ObservableStatus<T> {\n  const idField = options ? checkIdField(options) : 'NO_ID_FIELD';\n\n  const observableId = `firestore:docData:${ref.firestore.app.name}:${ref.path}:idField=${idField}`;\n  const observable = docData(ref, idField);\n\n  return useObservable(observableId, observable, options);\n}\n\n/**\n * Get a firestore document and don't subscribe to changes\n *\n * @param ref - Reference to the document you want to get\n * @param options\n */\nexport function useFirestoreDocDataOnce<T = unknown>(ref: firebase.firestore.DocumentReference, options?: ReactFireOptions<T>): ObservableStatus<T> {\n  const idField = options ? checkIdField(options) : 'NO_ID_FIELD';\n\n  const observableId = `firestore:docDataOnce:${ref.firestore.app.name}:${ref.path}:idField=${idField}`;\n  const observable$ = docData(ref, idField).pipe(first());\n\n  return useObservable(observableId, observable$, options);\n}\n\n/**\n * Subscribe to a Firestore collection\n *\n * @param ref - Reference to the collection you want to listen to\n * @param options\n */\nexport function useFirestoreCollection<T = { [key: string]: unknown }>(\n  query: firebase.firestore.Query,\n  options?: ReactFireOptions<T[]>\n): ObservableStatus<T extends {} ? T[] : firebase.firestore.QuerySnapshot> {\n  const observableId = `firestore:collection:${getUniqueIdForFirestoreQuery(query)}`;\n  const observable$ = fromCollectionRef(query);\n\n  return useObservable(observableId, observable$, options);\n}\n\n/**\n * Subscribe to a Firestore collection and unwrap the snapshot.\n *\n * @param ref - Reference to the collection you want to listen to\n * @param options\n */\nexport function useFirestoreCollectionData<T = { [key: string]: unknown }>(\n  query: firebase.firestore.Query,\n  options?: ReactFireOptions<T[]>\n): ObservableStatus<T[]> {\n  const idField = options ? checkIdField(options) : 'NO_ID_FIELD';\n  const observableId = `firestore:collectionData:${getUniqueIdForFirestoreQuery(query)}:idField=${idField}`;\n  const observable$ = collectionData(query, idField);\n\n  return useObservable(observableId, observable$, options);\n}\n","import * as React from 'react';\nimport { preloadPerformance } from './';\nimport { useFirebaseApp } from './firebaseApp';\n\nexport interface SuspensePerfProps {\n  children: React.ReactNode;\n  traceId: string;\n  fallback: React.ReactNode;\n  firePerf?: import('firebase/app').default.performance.Performance;\n}\n\nexport function SuspenseWithPerf({ children, traceId, fallback, firePerf }: SuspensePerfProps): JSX.Element {\n  if (!firePerf) {\n    const firebaseApp = useFirebaseApp();\n    preloadPerformance({ firebaseApp }).then(perf => perf());\n  }\n\n  const entries = performance?.getEntriesByName(traceId, 'measure') || [];\n  const startMarkName = `_${traceId}Start[${entries.length}]`;\n  const endMarkName = `_${traceId}End[${entries.length}]`;\n\n  const Fallback = () => {\n    React.useLayoutEffect(() => {\n      performance?.mark(startMarkName);\n\n      return () => {\n        performance?.mark(endMarkName);\n        performance?.measure(traceId, startMarkName, endMarkName);\n      };\n    }, []);\n\n    return <>{fallback}</>;\n  };\n\n  return <React.Suspense fallback={<Fallback />}>{children}</React.Suspense>;\n}\n","import { Observable } from 'rxjs';\n\ntype RemoteConfig = import('firebase/app').default.remoteConfig.RemoteConfig;\ntype RemoteConfigValue = import('firebase/app').default.remoteConfig.Value;\n\nexport type AllParameters = {\n  [key: string]: RemoteConfigValue;\n};\n\ninterface ParameterSettings<T> {\n  remoteConfig: RemoteConfig;\n  key: string;\n  getter: (key: string) => T;\n}\n\n// TODO(davideast): Replace with RxFire functions when they land\nfunction parameter$<T>({ remoteConfig, key, getter }: ParameterSettings<T>): Observable<T> {\n  return new Observable(subscriber => {\n    remoteConfig.ensureInitialized().then(() => {\n      // 'this' for the getter loses context in the next()\n      // call, so it needs to be bound.\n      subscriber.next(getter.bind(remoteConfig)(key));\n    });\n  });\n}\n\nexport function getValue(remoteConfig: RemoteConfig, key: string) {\n  const getter = remoteConfig.getValue;\n  return parameter$({ remoteConfig, key, getter });\n}\n\nexport function getString(remoteConfig: RemoteConfig, key: string) {\n  const getter = remoteConfig.getString;\n  return parameter$<string>({ remoteConfig, key, getter });\n}\n\nexport function getNumber(remoteConfig: RemoteConfig, key: string) {\n  const getter = remoteConfig.getNumber;\n  return parameter$<number>({ remoteConfig, key, getter });\n}\n\nexport function getBoolean(remoteConfig: RemoteConfig, key: string) {\n  const getter = remoteConfig.getBoolean;\n  return parameter$<boolean>({ remoteConfig, key, getter });\n}\n\nexport function getAll(remoteConfig: RemoteConfig) {\n  const getter = remoteConfig.getAll;\n  // No key is needed for getAll()\n  return parameter$<AllParameters>({ remoteConfig, key: '', getter });\n}\n","import { useRemoteConfig } from '../firebaseApp';\nimport { useObservable, ObservableStatus } from '../useObservable';\nimport { getValue, getString, getBoolean, getNumber, getAll, AllParameters } from './getValue';\nimport { Observable } from 'rxjs';\n\ntype RemoteConfig = import('firebase/app').default.remoteConfig.RemoteConfig;\ntype RemoteConfigValue = import('firebase/app').default.remoteConfig.Value;\ntype Getter$<T> = (remoteConfig: RemoteConfig, key: string) => Observable<T>;\n\ninterface RemoteConfigWithPrivate extends RemoteConfig {\n  // This is a private API, assume optional\n  _storage?: { appName: string };\n}\n\n/**\n * Helper function to construct type safe functions. Since Remote Config has\n * methods that return different types for values, we need to be extra safe\n * to make sure we are not returning improper types by accident.\n * @param key\n * @param getter\n * @param remoteConfig\n */\nfunction useRemoteConfigValue_INTERNAL<T>(key: string, getter: Getter$<T>, remoteConfig?: RemoteConfig): ObservableStatus<T> {\n  // TODO: Find an alternative that doesn't break the rules of hooks (conditional hook call)\n  remoteConfig = remoteConfig || useRemoteConfig();\n\n  // INVESTIGATE need to use a public API to get at the app name, one doesn't appear to exist...\n  // we might need to iterate over the Firebase apps and check for remoteConfig equality? this works for now\n  const appName = (remoteConfig as RemoteConfigWithPrivate)._storage?.appName;\n  const $value = getter(remoteConfig, key);\n\n  const observableId = `remoteConfig:${key}:${getter.name}:${appName}`;\n  return useObservable<T>(observableId, $value);\n}\n\n/**\n * Accepts a key and optionally a Remote Config instance. Returns a\n * Remote Config Value.\n *\n * @param key The parameter key in Remote Config\n * @param remoteConfig Optional instance. If not provided ReactFire will either grab the default instance or lazy load.\n */\nexport function useRemoteConfigValue(key: string, remoteConfig?: RemoteConfig): ObservableStatus<RemoteConfigValue> {\n  return useRemoteConfigValue_INTERNAL<RemoteConfigValue>(key, getValue, remoteConfig);\n}\n\n/**\n * Convience method similar to useRemoteConfigValue. Returns a `string` from a Remote Config parameter.\n * @param key The parameter key in Remote Config\n * @param remoteConfig Optional instance. If not provided ReactFire will either grab the default instance or lazy load.\n */\nexport function useRemoteConfigString(key: string, remoteConfig?: RemoteConfig): ObservableStatus<string> {\n  return useRemoteConfigValue_INTERNAL<string>(key, getString, remoteConfig);\n}\n\n/**\n * Convience method similar to useRemoteConfigValue. Returns a `number` from a Remote Config parameter.\n * @param key The parameter key in Remote Config\n * @param remoteConfig Optional instance. If not provided ReactFire will either grab the default instance or lazy load.\n */\nexport function useRemoteConfigNumber(key: string, remoteConfig?: RemoteConfig): ObservableStatus<number> {\n  return useRemoteConfigValue_INTERNAL<number>(key, getNumber, remoteConfig);\n}\n\n/**\n * Convience method similar to useRemoteConfigValue. Returns a `boolean` from a Remote Config parameter.\n * @param key The parameter key in Remote Config\n * @param remoteConfig Optional instance. If not provided ReactFire will either grab the default instance or lazy load.\n */\nexport function useRemoteConfigBoolean(key: string, remoteConfig?: RemoteConfig): ObservableStatus<boolean> {\n  return useRemoteConfigValue_INTERNAL<boolean>(key, getBoolean, remoteConfig);\n}\n\n/**\n * Convience method similar to useRemoteConfigValue. Returns allRemote Config parameters.\n * @param key The parameter key in Remote Config\n * @param remoteConfig Optional instance. If not provided ReactFire will either grab the default instance or lazy load.\n */\nexport function useRemoteConfigAll(key: string, remoteConfig?: RemoteConfig): ObservableStatus<AllParameters> {\n  return useRemoteConfigValue_INTERNAL<AllParameters>(key, getAll, remoteConfig);\n}\n","import firebase from 'firebase/app';\nimport * as React from 'react';\nimport { getDownloadURL } from 'rxfire/storage';\nimport { Observable } from 'rxjs';\nimport { ReactFireOptions, useObservable, ObservableStatus } from './';\nimport { useStorage, useSuspenseEnabledFromConfigAndContext } from './firebaseApp';\n\n/**\n * modified version of rxFire's _fromTask\n *\n * @param task\n */\nfunction _fromTask(task: firebase.storage.UploadTask) {\n  return new Observable<firebase.storage.UploadTaskSnapshot>(subscriber => {\n    const progress = (snap: firebase.storage.UploadTaskSnapshot) => {\n      return subscriber.next(snap);\n    };\n    const error = (e: any) => subscriber.error(e);\n    const complete = () => {\n      return subscriber.complete();\n    };\n    task.on('state_changed', progress, error, complete);\n\n    // I REMOVED THE UNSUBSCRIBE RETURN BECAUSE IT CANCELS THE UPLOAD\n    // https://github.com/firebase/firebase-js-sdk/issues/1659\n  });\n}\n\n/**\n * Subscribe to the progress of a storage task\n *\n * @param task - the task you want to listen to\n * @param ref - reference to the blob the task is acting on\n * @param options\n */\nexport function useStorageTask<T = unknown>(\n  task: firebase.storage.UploadTask,\n  ref: firebase.storage.Reference,\n  options?: ReactFireOptions<T>\n): ObservableStatus<firebase.storage.UploadTaskSnapshot | T> {\n  const observableId = `storage:task:${ref.toString()}`;\n  const observable$ = _fromTask(task);\n\n  return useObservable(observableId, observable$, options ? options.initialData : undefined);\n}\n\n/**\n * Subscribe to a storage ref's download URL\n *\n * @param ref - reference to the blob you want to download\n * @param options\n */\nexport function useStorageDownloadURL<T = string>(ref: firebase.storage.Reference, options?: ReactFireOptions<T>): ObservableStatus<string | T> {\n  const observableId = `storage:downloadUrl:${ref.toString()}`;\n  const observable$ = getDownloadURL(ref);\n\n  return useObservable(observableId, observable$, options);\n}\n\ntype StorageImageProps = {\n  storagePath: string;\n  storage?: firebase.storage.Storage;\n  suspense?: boolean;\n  placeHolder?: JSX.Element;\n};\n\nfunction StorageFromContext(props: StorageImageProps & React.DetailedHTMLProps<React.ImgHTMLAttributes<HTMLImageElement>, HTMLImageElement>) {\n  const storage = useStorage();\n\n  props = { ...props, storage };\n\n  return <INTERNALStorageImage {...props} />;\n}\n\nfunction INTERNALStorageImage(props: StorageImageProps & React.DetailedHTMLProps<React.ImgHTMLAttributes<HTMLImageElement>, HTMLImageElement>): JSX.Element {\n  let { storage, storagePath, suspense, placeHolder, ...imgProps } = props;\n\n  const reactfireOptions: ReactFireOptions<string> = {\n    suspense: useSuspenseEnabledFromConfigAndContext(suspense)\n  };\n\n  if (!storage) {\n    throw new Error('Storage was not passed to component INTERNALStorageImage. This should not be possible');\n  }\n\n  const { status, data: imgSrc } = useStorageDownloadURL(storage.ref(storagePath), reactfireOptions);\n\n  if (status === 'success') {\n    if (!(imgProps.alt || imgProps.alt === '')) {\n      console.warn(\n        `No alt prop provided for StorageImage with storagePath \"${storagePath}\"`,\n        'img elements must have an alt prop, either with meaningful text, or an empty string for decorative images'\n      );\n    }\n\n    return <img src={imgSrc} alt={imgProps.alt} {...imgProps} />;\n  } else {\n    return placeHolder ?? <>''</>;\n  }\n}\n\nexport function StorageImage(props: StorageImageProps & React.DetailedHTMLProps<React.ImgHTMLAttributes<HTMLImageElement>, HTMLImageElement>) {\n  let { storage } = props;\n\n  if (storage) {\n    return <INTERNALStorageImage {...props} />;\n  } else {\n    return <StorageFromContext {...props} />;\n  }\n}\n","import firebase from 'firebase/app';\nimport { SuspenseSubject } from './SuspenseSubject';\n\nexport type ReactFireGlobals = {\n  _reactFireDatabaseCachedQueries: Array<firebase.database.Query>;\n  _reactFireFirestoreQueryCache: Array<firebase.firestore.Query>;\n  _reactFirePreloadedObservables: Map<string, SuspenseSubject<any>>;\n};\n\nexport interface ReactFireOptions<T = unknown> {\n  idField?: string;\n  initialData?: T | any;\n  suspense?: boolean;\n}\n\nexport function checkOptions(options: ReactFireOptions, field: string) {\n  // make sure the field passed in is a valid key of ReactFire Options\n  if (field === 'idField' || field === 'initialData' || field === 'suspense') {\n    return options ? (options[field] as ReactFireOptions['idField'] | ReactFireOptions['initialData'] | ReactFireOptions['suspense']) : undefined;\n  }\n\n  throw new Error(`Field \"${field}\" is not a valid key in ReactFireOptions`);\n}\n\nexport function checkinitialData(options: ReactFireOptions) {\n  return checkOptions(options, 'initialData');\n}\n\nexport function checkIdField(options: ReactFireOptions) {\n  return checkOptions(options, 'idField');\n}\n\nexport * from './auth';\nexport * from './database';\nexport * from './firebaseApp';\nexport * from './firestore';\nexport * from './performance';\nexport * from './remote-config';\nexport * from './storage';\nexport * from './useObservable';\n"]},"metadata":{},"sourceType":"module"}